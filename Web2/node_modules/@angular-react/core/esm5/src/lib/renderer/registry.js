// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var elementMap = new Map();
var camelCaseSplit = /([a-z0-9])([A-Z])/g;
/**
 * Register an element to be renderer when the renderer sees the tag.
 * @param elementName the tag to be used to get the component type when rendering.
 * @param resolver A resolver to the React component.
 */
export function registerElement(elementName, resolver) {
    if (elementMap.has(elementName)) {
        // Ignore multiple register attempts for the same component.
        // Angular doesn't allow sharing whole NgModule instances (in this case, an @NgModule for React-wrapped components) with lazy-loaded @NgModules (in the app),
        // To keep the API simple, allow multiple calls to `registerElement`.
        // Disadvantage is that you can't replace (React) component implementations at runtime. This sounds far-fetched, but solvable with a `static forRoot()` pattern for every
        // React-wrapper components' @NgModule, ensuring that `registerElement` is only called once.
        return;
    }
    else {
        var entry = { resolver: resolver };
        elementMap.set(elementName, entry);
        elementMap.set(elementName.toLowerCase(), entry);
        elementMap.set(elementName.replace(camelCaseSplit, '$1-$2').toLowerCase(), entry);
    }
}
export function isKnownComponent(elementName) {
    return elementMap.has(elementName) || elementMap.has(elementName.toLowerCase());
}
export function getComponentClass(elementName) {
    var entry = elementMap.get(elementName) || elementMap.get(elementName.toLowerCase());
    if (!entry) {
        // throw new TypeError(`No known component for element ${elementName}.`);
        return elementName;
    }
    try {
        return entry.resolver();
    }
    catch (e) {
        throw new TypeError("Could not load component for: " + elementName + "." + e);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVnaXN0cnkuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AYW5ndWxhci1yZWFjdC9jb3JlLyIsInNvdXJjZXMiOlsic3JjL2xpYi9yZW5kZXJlci9yZWdpc3RyeS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSw0REFBNEQ7QUFDNUQsa0NBQWtDO0FBTWxDLElBQU0sVUFBVSxHQUFHLElBQUksR0FBRyxFQUEyQyxDQUFDO0FBQ3RFLElBQU0sY0FBYyxHQUFHLG9CQUFvQixDQUFDO0FBRTVDOzs7O0dBSUc7QUFDSCxNQUFNLFVBQVUsZUFBZSxDQUFDLFdBQW1CLEVBQUUsUUFBMkI7SUFDOUUsSUFBSSxVQUFVLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxFQUFFO1FBQy9CLDREQUE0RDtRQUM1RCw2SkFBNko7UUFDN0oscUVBQXFFO1FBQ3JFLHlLQUF5SztRQUN6Syw0RkFBNEY7UUFDNUYsT0FBTztLQUNSO1NBQU07UUFDTCxJQUFNLEtBQUssR0FBRyxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsQ0FBQztRQUNyQyxVQUFVLENBQUMsR0FBRyxDQUFDLFdBQVcsRUFBRSxLQUFLLENBQUMsQ0FBQztRQUNuQyxVQUFVLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxXQUFXLEVBQUUsRUFBRSxLQUFLLENBQUMsQ0FBQztRQUNqRCxVQUFVLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsY0FBYyxFQUFFLE9BQU8sQ0FBQyxDQUFDLFdBQVcsRUFBRSxFQUFFLEtBQUssQ0FBQyxDQUFDO0tBQ25GO0FBQ0gsQ0FBQztBQUVELE1BQU0sVUFBVSxnQkFBZ0IsQ0FBQyxXQUFtQjtJQUNsRCxPQUFPLFVBQVUsQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLElBQUksVUFBVSxDQUFDLEdBQUcsQ0FBQyxXQUFXLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQztBQUNsRixDQUFDO0FBRUQsTUFBTSxVQUFVLGlCQUFpQixDQUFDLFdBQW1CO0lBQ25ELElBQU0sS0FBSyxHQUFHLFVBQVUsQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLElBQUksVUFBVSxDQUFDLEdBQUcsQ0FBQyxXQUFXLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQztJQUN2RixJQUFJLENBQUMsS0FBSyxFQUFFO1FBQ1YseUVBQXlFO1FBQ3pFLE9BQU8sV0FBVyxDQUFDO0tBQ3BCO0lBRUQsSUFBSTtRQUNGLE9BQU8sS0FBSyxDQUFDLFFBQVEsRUFBRSxDQUFDO0tBQ3pCO0lBQUMsT0FBTyxDQUFDLEVBQUU7UUFDVixNQUFNLElBQUksU0FBUyxDQUFDLG1DQUFpQyxXQUFXLFNBQUksQ0FBRyxDQUFDLENBQUM7S0FDMUU7QUFDSCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuXHJcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcclxuXHJcbmV4cG9ydCB0eXBlIENvbXBvbmVudFJlc29sdmVyID0gKCkgPT4gUmVhY3QuUmVhY3RUeXBlO1xyXG5cclxuY29uc3QgZWxlbWVudE1hcCA9IG5ldyBNYXA8c3RyaW5nLCB7IHJlc29sdmVyOiBDb21wb25lbnRSZXNvbHZlciB9PigpO1xyXG5jb25zdCBjYW1lbENhc2VTcGxpdCA9IC8oW2EtejAtOV0pKFtBLVpdKS9nO1xyXG5cclxuLyoqXHJcbiAqIFJlZ2lzdGVyIGFuIGVsZW1lbnQgdG8gYmUgcmVuZGVyZXIgd2hlbiB0aGUgcmVuZGVyZXIgc2VlcyB0aGUgdGFnLlxyXG4gKiBAcGFyYW0gZWxlbWVudE5hbWUgdGhlIHRhZyB0byBiZSB1c2VkIHRvIGdldCB0aGUgY29tcG9uZW50IHR5cGUgd2hlbiByZW5kZXJpbmcuXHJcbiAqIEBwYXJhbSByZXNvbHZlciBBIHJlc29sdmVyIHRvIHRoZSBSZWFjdCBjb21wb25lbnQuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJFbGVtZW50KGVsZW1lbnROYW1lOiBzdHJpbmcsIHJlc29sdmVyOiBDb21wb25lbnRSZXNvbHZlcik6IHZvaWQge1xyXG4gIGlmIChlbGVtZW50TWFwLmhhcyhlbGVtZW50TmFtZSkpIHtcclxuICAgIC8vIElnbm9yZSBtdWx0aXBsZSByZWdpc3RlciBhdHRlbXB0cyBmb3IgdGhlIHNhbWUgY29tcG9uZW50LlxyXG4gICAgLy8gQW5ndWxhciBkb2Vzbid0IGFsbG93IHNoYXJpbmcgd2hvbGUgTmdNb2R1bGUgaW5zdGFuY2VzIChpbiB0aGlzIGNhc2UsIGFuIEBOZ01vZHVsZSBmb3IgUmVhY3Qtd3JhcHBlZCBjb21wb25lbnRzKSB3aXRoIGxhenktbG9hZGVkIEBOZ01vZHVsZXMgKGluIHRoZSBhcHApLFxyXG4gICAgLy8gVG8ga2VlcCB0aGUgQVBJIHNpbXBsZSwgYWxsb3cgbXVsdGlwbGUgY2FsbHMgdG8gYHJlZ2lzdGVyRWxlbWVudGAuXHJcbiAgICAvLyBEaXNhZHZhbnRhZ2UgaXMgdGhhdCB5b3UgY2FuJ3QgcmVwbGFjZSAoUmVhY3QpIGNvbXBvbmVudCBpbXBsZW1lbnRhdGlvbnMgYXQgcnVudGltZS4gVGhpcyBzb3VuZHMgZmFyLWZldGNoZWQsIGJ1dCBzb2x2YWJsZSB3aXRoIGEgYHN0YXRpYyBmb3JSb290KClgIHBhdHRlcm4gZm9yIGV2ZXJ5XHJcbiAgICAvLyBSZWFjdC13cmFwcGVyIGNvbXBvbmVudHMnIEBOZ01vZHVsZSwgZW5zdXJpbmcgdGhhdCBgcmVnaXN0ZXJFbGVtZW50YCBpcyBvbmx5IGNhbGxlZCBvbmNlLlxyXG4gICAgcmV0dXJuO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBjb25zdCBlbnRyeSA9IHsgcmVzb2x2ZXI6IHJlc29sdmVyIH07XHJcbiAgICBlbGVtZW50TWFwLnNldChlbGVtZW50TmFtZSwgZW50cnkpO1xyXG4gICAgZWxlbWVudE1hcC5zZXQoZWxlbWVudE5hbWUudG9Mb3dlckNhc2UoKSwgZW50cnkpO1xyXG4gICAgZWxlbWVudE1hcC5zZXQoZWxlbWVudE5hbWUucmVwbGFjZShjYW1lbENhc2VTcGxpdCwgJyQxLSQyJykudG9Mb3dlckNhc2UoKSwgZW50cnkpO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGlzS25vd25Db21wb25lbnQoZWxlbWVudE5hbWU6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG4gIHJldHVybiBlbGVtZW50TWFwLmhhcyhlbGVtZW50TmFtZSkgfHwgZWxlbWVudE1hcC5oYXMoZWxlbWVudE5hbWUudG9Mb3dlckNhc2UoKSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRDb21wb25lbnRDbGFzcyhlbGVtZW50TmFtZTogc3RyaW5nKTogUmVhY3QuUmVhY3RUeXBlIHwgc3RyaW5nIHtcclxuICBjb25zdCBlbnRyeSA9IGVsZW1lbnRNYXAuZ2V0KGVsZW1lbnROYW1lKSB8fCBlbGVtZW50TWFwLmdldChlbGVtZW50TmFtZS50b0xvd2VyQ2FzZSgpKTtcclxuICBpZiAoIWVudHJ5KSB7XHJcbiAgICAvLyB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBrbm93biBjb21wb25lbnQgZm9yIGVsZW1lbnQgJHtlbGVtZW50TmFtZX0uYCk7XHJcbiAgICByZXR1cm4gZWxlbWVudE5hbWU7XHJcbiAgfVxyXG5cclxuICB0cnkge1xyXG4gICAgcmV0dXJuIGVudHJ5LnJlc29sdmVyKCk7XHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQ291bGQgbm90IGxvYWQgY29tcG9uZW50IGZvcjogJHtlbGVtZW50TmFtZX0uJHtlfWApO1xyXG4gIH1cclxufVxyXG4iXX0=