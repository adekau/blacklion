// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
import * as tslib_1 from "tslib";
import * as React from 'react';
import * as ReactDOM from 'react-dom';
import removeUndefinedProperties from '../utils/object/remove-undefined-properties';
import { CHILDREN_TO_APPEND_PROP } from './react-content';
import { getComponentClass } from './registry';
var DEBUG = false;
export function isReactNode(node) {
    return node.setRenderPendingCallback !== undefined;
}
/**
 * Logical representation of everything needed to render a React element in the
 * DOM, with the needed methods to do so.
 */
var ReactNode = /** @class */ (function () {
    function ReactNode(type) {
        this.type = type;
        // Access to these properties are restricted through setters and functions
        // so that the dirty "render pending" state of this object can be properly
        // tracked and all nodes with "render pending" can be flushed at the end
        // of a render operation.
        this._props = {};
        this._children = [];
        this._childrenToAppend = [];
        this._isDestroyPending = false;
        this._isRenderPending = true;
        this.setRenderPendingCallback = function () { return null; };
        this.setRenderPending();
        this._tryResolveTypeIsReactElementClass();
    }
    Object.defineProperty(ReactNode.prototype, "domElement", {
        get: function () {
            return this._renderedDomElement;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ReactNode.prototype, "parent", {
        get: function () {
            return this._parent;
        },
        set: function (parent) {
            this._parent = parent;
            this.setRenderPending();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ReactNode.prototype, "shouldRender", {
        get: function () {
            return !this._isNotRenderable;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ReactNode.prototype, "destroyPending", {
        get: function () {
            return this._isDestroyPending;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Track all pending render operations internally and set flag on
     * renderer factory so that a flush operation can be scheduled for
     * the "end" of render.
     */
    ReactNode.prototype.setRenderPending = function () {
        this.setRenderPendingCallback();
        this._isRenderPending = true;
    };
    /**
     * Marks the node to be removed from the DOM in the next render cycle.
     */
    ReactNode.prototype.destroyNode = function () {
        this.setRenderPending();
        this._isDestroyPending = true;
    };
    /**
     * Sets an attribute on the node.
     * @note the value can only be a `string`. See `setProperty` for other use-cases.
     * @see `Renderer2#setAttribute`.
     *
     * @param name The attribute name.
     * @param value The new value.
     */
    ReactNode.prototype.setAttribute = function (name, value) {
        var _a;
        this.setAttributes((_a = {}, _a[name] = value, _a));
    };
    /**
     * Set attributes on this node.
     * Note that values can only be of type `string`. See `setProperties` for other use-cases.
     * @see `Renderer2#setAttribute`.
     *
     * @param attributes the attributes to set.
     */
    ReactNode.prototype.setAttributes = function (attributes) {
        this.setProperties(attributes);
    };
    /**
     * Sets a prop in the underlying React element.
     * @see `Renderer2#setProperty`.
     *
     * @param name The property name.
     * @param value The new value.
     */
    ReactNode.prototype.setProperty = function (name, value) {
        var _a;
        this.setProperties((_a = {}, _a[name] = value, _a));
    };
    /**
     * Like `setProperty` but for multiple props at once.
     *
     * @param properties An object with the props.
     */
    ReactNode.prototype.setProperties = function (properties) {
        this.setRenderPending();
        Object.assign(this._props, removeUndefinedProperties(properties));
    };
    /**
     * Remove a prop or an attribute from the underlying React element.
     * @see `Renderer2#removeAttribute`.
     *
     * @param name The property name.
     * @param childName _Optional_ A property of `name` to remove instead.
     * @returns the deleted property
     */
    ReactNode.prototype.removeProperty = function (name, childName) {
        this.setRenderPending();
        if (childName) {
            return delete this._props[name][childName];
        }
        return delete this._props[name];
    };
    /**
     * Add a direct child of this node.
     * @see `Renderer2#addChild`.
     *
     * @param node The node to add.
     */
    ReactNode.prototype.addChild = function (node) {
        this.setRenderPending();
        this._children.push(node);
    };
    /**
     * Remove a direct child of this node.
     * @see `Renderer2#removeChild`.
     *
     * @param node The node to remove.
     */
    ReactNode.prototype.removeChild = function (node) {
        this.setRenderPending();
        this._children = this._children.filter(function (child) { return child !== node; });
    };
    /**
     * Cast the node to a comment node.
     * @see `Renderer2#createComment`.
     *
     * @param value the text in the comment to render.
     * @returns itself.
     */
    ReactNode.prototype.asComment = function (value) {
        this.setRenderPending();
        this.type = undefined;
        this._comment = value;
        return this;
    };
    /**
     * Cast the node to a text node.
     * @see `Renderer2#createText`.
     *
     * @param value the text to render.
     * @returns itself.
     */
    ReactNode.prototype.asText = function (value) {
        this.setRenderPending();
        this.type = undefined;
        this._text = value;
        // Skip appending and rendering of empty text nodes. This may cause a bug
        // if a single space is desired...
        if (!value || !value.trim()) {
            this._isNotRenderable = true;
        }
        return this;
    };
    /**
     * Render the node to the DOM, or unmount it, as necessary.
     *
     * @returns itself.
     */
    ReactNode.prototype.render = function () {
        // Only complete render operations for ReactNodes that are parented by HTMLElements.
        // Those that are parented by other ReactNodes will be rendered recursively by their
        // parent.
        if (!isReactNode(this._parent)) {
            if (this._isDestroyPending && this._parent) {
                if (DEBUG) {
                    console.log('ReactNode > render > destroy > node:', this.toString(), 'parent:', this.parent);
                }
                ReactDOM.unmountComponentAtNode(this._parent);
                return this;
            }
            if (this._isRenderPending) {
                if (DEBUG) {
                    console.log('ReactNode > render > node:', this.toString(), 'parent:', this.parent);
                }
                // It is expected that the element will be recreated and re-rendered with each attribute change.
                // See: https://reactjs.org/docs/rendering-elements.html
                ReactDOM.render(this._renderRecursive(), this._parent);
                this._isRenderPending = false;
            }
        }
        return this;
    };
    /**
     * Appends a child.
     *
     * @see `Renderer2#appendChild`.
     * @note This is called by Angular core when projected content is being added.
     *
     * @param projectedContent the content to project.
     */
    ReactNode.prototype.appendChild = function (projectedContent) {
        if (DEBUG) {
            console.error('ReactNode > appendChild > node:', this.toString(), 'projectedContent:', projectedContent.toString().trim());
        }
        this._childrenToAppend.push(projectedContent);
    };
    /**
     * @note for easier debugging.
     */
    ReactNode.prototype.toString = function () {
        if (this._typeName) {
            return "[" + this._typeName + " ReactNode]";
        }
        if (this._text) {
            return '[text ReactNode]';
        }
        if (this._comment) {
            return '[comment ReactNode]';
        }
        return '[undefined ReactNode]';
    };
    ReactNode.prototype._renderRecursive = function (key) {
        var children = this._children
            ? this._children.map(function (child, index) { return child._renderRecursive(index.toString()); })
            : [];
        if (this._text) {
            return this._text;
        }
        this._props[CHILDREN_TO_APPEND_PROP] = this._childrenToAppend;
        if (key) {
            this._props['key'] = key;
        }
        // Just having some props on a React element can cause it to
        // behave undesirably, and since the templates are hard-coded to pass
        // all Inputs all the time, they pass `undefined` values too.
        // This ensures these are removed.
        // Additionally, there are some things that Angular templating forbids,
        // and stops at-compile time (with errors), such as `Input`s being prefixed with `on`.
        // Since React does not have the notion of `Output`s as Angular (they are just props of type function, essentially callbacks).
        // To work around this, we, by convention, prefix any PascalCased prop with `on` here, after the template has already been compiled.
        var clearedProps = this._transformProps(removeUndefinedProperties(this._props));
        if (DEBUG) {
            console.warn('ReactNode > renderRecursive > type:', this.toString(), 'props:', this._props, 'children:', children);
        }
        return React.createElement(this.type, clearedProps, children.length > 0 ? children : undefined);
    };
    ReactNode.prototype._transformProps = function (props) {
        var _this = this;
        return Object.entries(props).reduce(function (acc, _a) {
            var _b;
            var _c = tslib_1.__read(_a, 2), key = _c[0], value = _c[1];
            var _d = tslib_1.__read(typeof key !== 'string' ? [key, value] : _this._transformProp(key, value), 2), newKey = _d[0], newValue = _d[1];
            return Object.assign(acc, (_b = {}, _b[newKey] = newValue, _b));
        }, {});
    };
    ReactNode.prototype._transformProp = function (name, value) {
        // prop name is camelCased already
        var firstLetter = name[0];
        if (firstLetter === firstLetter.toLowerCase()) {
            return [name, value];
        }
        // prop name is PascalCased & is a function - assuming render prop or callback prop that has return value
        // NOTE: Angular doesn't allow passing @Inputs that are prefixed with "on". This is useful for render props and properties representing the "on" state (for example, Toggle).
        // As a convention, any @Input that starts with a capital letter is prefixed with "on" when passed as a prop to the underlying React component.
        return ["on" + name, value];
    };
    ReactNode.prototype._tryResolveTypeIsReactElementClass = function () {
        if (this._typeIsReactElementClass === undefined) {
            // Comments and text have no type.
            if (!this.type) {
                return;
            }
            // Store the name of the type for the toString message (debugging).
            this._typeName = this.type;
            // Attempt to resolve the type as a React Element class name/type.
            // Since Angular templates are just strings, we can't include types in them.
            // Therefore, we use the component registry to resolve the type of a component from a string.
            if (typeof this.type === 'string') {
                this.type = getComponentClass(this.type);
            }
            // If type is still a string, then no React Element matches this string.
            this._typeIsReactElementClass = typeof this.type !== 'string';
            if (DEBUG) {
                console.log('ReactNode > tryResolveTypeIsReactElementClass > type:', this._typeName);
            }
        }
    };
    return ReactNode;
}());
export { ReactNode };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVhY3Qtbm9kZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0Bhbmd1bGFyLXJlYWN0L2NvcmUvIiwic291cmNlcyI6WyJzcmMvbGliL3JlbmRlcmVyL3JlYWN0LW5vZGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsNERBQTREO0FBQzVELGtDQUFrQzs7QUFFbEMsT0FBTyxLQUFLLEtBQUssTUFBTSxPQUFPLENBQUM7QUFDL0IsT0FBTyxLQUFLLFFBQVEsTUFBTSxXQUFXLENBQUM7QUFHdEMsT0FBTyx5QkFBeUIsTUFBTSw2Q0FBNkMsQ0FBQztBQUNwRixPQUFPLEVBQUUsdUJBQXVCLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUMxRCxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxZQUFZLENBQUM7QUFFL0MsSUFBTSxLQUFLLEdBQUcsS0FBSyxDQUFDO0FBRXBCLE1BQU0sVUFBVSxXQUFXLENBQUMsSUFBUztJQUNuQyxPQUFtQixJQUFLLENBQUMsd0JBQXdCLEtBQUssU0FBUyxDQUFDO0FBQ2xFLENBQUM7QUFFRDs7O0dBR0c7QUFDSDtJQXVDRSxtQkFBb0IsSUFBK0I7UUFBL0IsU0FBSSxHQUFKLElBQUksQ0FBMkI7UUF0Q25ELDBFQUEwRTtRQUMxRSwwRUFBMEU7UUFDMUUsd0VBQXdFO1FBQ3hFLHlCQUF5QjtRQUNqQixXQUFNLEdBQUcsRUFBRSxDQUFDO1FBSVosY0FBUyxHQUFxQixFQUFFLENBQUM7UUFFakMsc0JBQWlCLEdBQXVCLEVBQUUsQ0FBQztRQUkzQyxzQkFBaUIsR0FBWSxLQUFLLENBQUM7UUFDbkMscUJBQWdCLEdBQUcsSUFBSSxDQUFDO1FBNEJoQyw2QkFBd0IsR0FBRyxjQUFNLE9BQUEsSUFBSSxFQUFKLENBQUksQ0FBQztRQUpwQyxJQUFJLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztRQUN4QixJQUFJLENBQUMsa0NBQWtDLEVBQUUsQ0FBQztJQUM1QyxDQUFDO0lBeEJELHNCQUFJLGlDQUFVO2FBQWQ7WUFDRSxPQUFPLElBQUks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SUFnVkMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG5cclxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgKiBhcyBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xyXG5cclxuaW1wb3J0IHsgU3RyaW5nTWFwIH0gZnJvbSAnLi4vZGVjbGFyYXRpb25zL3N0cmluZy1tYXAnO1xyXG5pbXBvcnQgcmVtb3ZlVW5kZWZpbmVkUHJvcGVydGllcyBmcm9tICcuLi91dGlscy9vYmplY3QvcmVtb3ZlLXVuZGVmaW5lZC1wcm9wZXJ0aWVzJztcclxuaW1wb3J0IHsgQ0hJTERSRU5fVE9fQVBQRU5EX1BST1AgfSBmcm9tICcuL3JlYWN0LWNvbnRlbnQnO1xyXG5pbXBvcnQgeyBnZXRDb21wb25lbnRDbGFzcyB9IGZyb20gJy4vcmVnaXN0cnknO1xyXG5cclxuY29uc3QgREVCVUcgPSBmYWxzZTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpc1JlYWN0Tm9kZShub2RlOiBhbnkpOiBub2RlIGlzIFJlYWN0Tm9kZSB7XHJcbiAgcmV0dXJuICg8UmVhY3ROb2RlPm5vZGUpLnNldFJlbmRlclBlbmRpbmdDYWxsYmFjayAhPT0gdW5kZWZpbmVkO1xyXG59XHJcblxyXG4vKipcclxuICogTG9naWNhbCByZXByZXNlbnRhdGlvbiBvZiBldmVyeXRoaW5nIG5lZWRlZCB0byByZW5kZXIgYSBSZWFjdCBlbGVtZW50IGluIHRoZVxyXG4gKiBET00sIHdpdGggdGhlIG5lZWRlZCBtZXRob2RzIHRvIGRvIHNvLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFJlYWN0Tm9kZSB7XHJcbiAgLy8gQWNjZXNzIHRvIHRoZXNlIHByb3BlcnRpZXMgYXJlIHJlc3RyaWN0ZWQgdGhyb3VnaCBzZXR0ZXJzIGFuZCBmdW5jdGlvbnNcclxuICAvLyBzbyB0aGF0IHRoZSBkaXJ0eSBcInJlbmRlciBwZW5kaW5nXCIgc3RhdGUgb2YgdGhpcyBvYmplY3QgY2FuIGJlIHByb3Blcmx5XHJcbiAgLy8gdHJhY2tlZCBhbmQgYWxsIG5vZGVzIHdpdGggXCJyZW5kZXIgcGVuZGluZ1wiIGNhbiBiZSBmbHVzaGVkIGF0IHRoZSBlbmRcclxuICAvLyBvZiBhIHJlbmRlciBvcGVyYXRpb24uXHJcbiAgcHJpdmF0ZSBfcHJvcHMgPSB7fTtcclxuICBwcml2YXRlIF9jb21tZW50OiBzdHJpbmc7XHJcbiAgcHJpdmF0ZSBfdGV4dDogc3RyaW5nO1xyXG4gIHByaXZhdGUgX3R5cGVJc1JlYWN0RWxlbWVudENsYXNzOiBib29sZWFuIHwgdW5kZWZpbmVkO1xyXG4gIHByaXZhdGUgX2NoaWxkcmVuOiBBcnJheTxSZWFjdE5vZGU+ID0gW107XHJcbiAgcHJpdmF0ZSBfdHlwZU5hbWU6IHN0cmluZztcclxuICBwcml2YXRlIF9jaGlsZHJlblRvQXBwZW5kOiBBcnJheTxIVE1MRWxlbWVudD4gPSBbXTtcclxuICBwcml2YXRlIF9yZW5kZXJlZERvbUVsZW1lbnQ6IEhUTUxFbGVtZW50O1xyXG4gIHByaXZhdGUgX3BhcmVudDogSFRNTEVsZW1lbnQgfCBSZWFjdE5vZGU7XHJcbiAgcHJpdmF0ZSBfaXNOb3RSZW5kZXJhYmxlOiBib29sZWFuO1xyXG4gIHByaXZhdGUgX2lzRGVzdHJveVBlbmRpbmc6IGJvb2xlYW4gPSBmYWxzZTtcclxuICBwcml2YXRlIF9pc1JlbmRlclBlbmRpbmcgPSB0cnVlO1xyXG5cclxuICBnZXQgZG9tRWxlbWVudCgpIHtcclxuICAgIHJldHVybiB0aGlzLl9yZW5kZXJlZERvbUVsZW1lbnQ7XHJcbiAgfVxyXG5cclxuICBzZXQgcGFyZW50KHBhcmVudDogSFRNTEVsZW1lbnQgfCBSZWFjdE5vZGUpIHtcclxuICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcclxuICAgIHRoaXMuc2V0UmVuZGVyUGVuZGluZygpO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHBhcmVudCgpOiBIVE1MRWxlbWVudCB8IFJlYWN0Tm9kZSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcGFyZW50O1xyXG4gIH1cclxuXHJcbiAgZ2V0IHNob3VsZFJlbmRlcigpIHtcclxuICAgIHJldHVybiAhdGhpcy5faXNOb3RSZW5kZXJhYmxlO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGRlc3Ryb3lQZW5kaW5nKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2lzRGVzdHJveVBlbmRpbmc7XHJcbiAgfVxyXG5cclxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHR5cGU/OiBSZWFjdC5SZWFjdFR5cGUgfCBzdHJpbmcpIHtcclxuICAgIHRoaXMuc2V0UmVuZGVyUGVuZGluZygpO1xyXG4gICAgdGhpcy5fdHJ5UmVzb2x2ZVR5cGVJc1JlYWN0RWxlbWVudENsYXNzKCk7XHJcbiAgfVxyXG5cclxuICBzZXRSZW5kZXJQZW5kaW5nQ2FsbGJhY2sgPSAoKSA9PiBudWxsO1xyXG5cclxuICAvKipcclxuICAgKiBUcmFjayBhbGwgcGVuZGluZyByZW5kZXIgb3BlcmF0aW9ucyBpbnRlcm5hbGx5IGFuZCBzZXQgZmxhZyBvblxyXG4gICAqIHJlbmRlcmVyIGZhY3Rvcnkgc28gdGhhdCBhIGZsdXNoIG9wZXJhdGlvbiBjYW4gYmUgc2NoZWR1bGVkIGZvclxyXG4gICAqIHRoZSBcImVuZFwiIG9mIHJlbmRlci5cclxuICAgKi9cclxuICBzZXRSZW5kZXJQZW5kaW5nKCkge1xyXG4gICAgdGhpcy5zZXRSZW5kZXJQZW5kaW5nQ2FsbGJhY2soKTtcclxuICAgIHRoaXMuX2lzUmVuZGVyUGVuZGluZyA9IHRydWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNYXJrcyB0aGUgbm9kZSB0byBiZSByZW1vdmVkIGZyb20gdGhlIERPTSBpbiB0aGUgbmV4dCByZW5kZXIgY3ljbGUuXHJcbiAgICovXHJcbiAgZGVzdHJveU5vZGUoKSB7XHJcbiAgICB0aGlzLnNldFJlbmRlclBlbmRpbmcoKTtcclxuICAgIHRoaXMuX2lzRGVzdHJveVBlbmRpbmcgPSB0cnVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0cyBhbiBhdHRyaWJ1dGUgb24gdGhlIG5vZGUuXHJcbiAgICogQG5vdGUgdGhlIHZhbHVlIGNhbiBvbmx5IGJlIGEgYHN0cmluZ2AuIFNlZSBgc2V0UHJvcGVydHlgIGZvciBvdGhlciB1c2UtY2FzZXMuXHJcbiAgICogQHNlZSBgUmVuZGVyZXIyI3NldEF0dHJpYnV0ZWAuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gbmFtZSBUaGUgYXR0cmlidXRlIG5hbWUuXHJcbiAgICogQHBhcmFtIHZhbHVlIFRoZSBuZXcgdmFsdWUuXHJcbiAgICovXHJcbiAgc2V0QXR0cmlidXRlKG5hbWU6IHN0cmluZywgdmFsdWU6IHN0cmluZykge1xyXG4gICAgdGhpcy5zZXRBdHRyaWJ1dGVzKHsgW25hbWVdOiB2YWx1ZSB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldCBhdHRyaWJ1dGVzIG9uIHRoaXMgbm9kZS5cclxuICAgKiBOb3RlIHRoYXQgdmFsdWVzIGNhbiBvbmx5IGJlIG9mIHR5cGUgYHN0cmluZ2AuIFNlZSBgc2V0UHJvcGVydGllc2AgZm9yIG90aGVyIHVzZS1jYXNlcy5cclxuICAgKiBAc2VlIGBSZW5kZXJlcjIjc2V0QXR0cmlidXRlYC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBhdHRyaWJ1dGVzIHRoZSBhdHRyaWJ1dGVzIHRvIHNldC5cclxuICAgKi9cclxuICBzZXRBdHRyaWJ1dGVzKGF0dHJpYnV0ZXM6IFN0cmluZ01hcDxzdHJpbmc+KSB7XHJcbiAgICB0aGlzLnNldFByb3BlcnRpZXMoYXR0cmlidXRlcyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXRzIGEgcHJvcCBpbiB0aGUgdW5kZXJseWluZyBSZWFjdCBlbGVtZW50LlxyXG4gICAqIEBzZWUgYFJlbmRlcmVyMiNzZXRQcm9wZXJ0eWAuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gbmFtZSBUaGUgcHJvcGVydHkgbmFtZS5cclxuICAgKiBAcGFyYW0gdmFsdWUgVGhlIG5ldyB2YWx1ZS5cclxuICAgKi9cclxuICBzZXRQcm9wZXJ0eShuYW1lOiBzdHJpbmcsIHZhbHVlOiBhbnkpIHtcclxuICAgIHRoaXMuc2V0UHJvcGVydGllcyh7IFtuYW1lXTogdmFsdWUgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBMaWtlIGBzZXRQcm9wZXJ0eWAgYnV0IGZvciBtdWx0aXBsZSBwcm9wcyBhdCBvbmNlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHByb3BlcnRpZXMgQW4gb2JqZWN0IHdpdGggdGhlIHByb3BzLlxyXG4gICAqL1xyXG4gIHNldFByb3BlcnRpZXMocHJvcGVydGllczogU3RyaW5nTWFwKSB7XHJcbiAgICB0aGlzLnNldFJlbmRlclBlbmRpbmcoKTtcclxuICAgIE9iamVjdC5hc3NpZ24odGhpcy5fcHJvcHMsIHJlbW92ZVVuZGVmaW5lZFByb3BlcnRpZXMocHJvcGVydGllcykpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlIGEgcHJvcCBvciBhbiBhdHRyaWJ1dGUgZnJvbSB0aGUgdW5kZXJseWluZyBSZWFjdCBlbGVtZW50LlxyXG4gICAqIEBzZWUgYFJlbmRlcmVyMiNyZW1vdmVBdHRyaWJ1dGVgLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIG5hbWUgVGhlIHByb3BlcnR5IG5hbWUuXHJcbiAgICogQHBhcmFtIGNoaWxkTmFtZSBfT3B0aW9uYWxfIEEgcHJvcGVydHkgb2YgYG5hbWVgIHRvIHJlbW92ZSBpbnN0ZWFkLlxyXG4gICAqIEByZXR1cm5zIHRoZSBkZWxldGVkIHByb3BlcnR5XHJcbiAgICovXHJcbiAgcmVtb3ZlUHJvcGVydHkobmFtZTogc3RyaW5nLCBjaGlsZE5hbWU/OiBzdHJpbmcpIHtcclxuICAgIHRoaXMuc2V0UmVuZGVyUGVuZGluZygpO1xyXG4gICAgaWYgKGNoaWxkTmFtZSkge1xyXG4gICAgICByZXR1cm4gZGVsZXRlIHRoaXMuX3Byb3BzW25hbWVdW2NoaWxkTmFtZV07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGRlbGV0ZSB0aGlzLl9wcm9wc1tuYW1lXTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZCBhIGRpcmVjdCBjaGlsZCBvZiB0aGlzIG5vZGUuXHJcbiAgICogQHNlZSBgUmVuZGVyZXIyI2FkZENoaWxkYC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBub2RlIFRoZSBub2RlIHRvIGFkZC5cclxuICAgKi9cclxuICBhZGRDaGlsZChub2RlOiBSZWFjdE5vZGUpIHtcclxuICAgIHRoaXMuc2V0UmVuZGVyUGVuZGluZygpO1xyXG4gICAgdGhpcy5fY2hpbGRyZW4ucHVzaChub2RlKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbW92ZSBhIGRpcmVjdCBjaGlsZCBvZiB0aGlzIG5vZGUuXHJcbiAgICogQHNlZSBgUmVuZGVyZXIyI3JlbW92ZUNoaWxkYC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBub2RlIFRoZSBub2RlIHRvIHJlbW92ZS5cclxuICAgKi9cclxuICByZW1vdmVDaGlsZChub2RlOiBSZWFjdE5vZGUpIHtcclxuICAgIHRoaXMuc2V0UmVuZGVyUGVuZGluZygpO1xyXG4gICAgdGhpcy5fY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbi5maWx0ZXIoY2hpbGQgPT4gY2hpbGQgIT09IG5vZGUpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2FzdCB0aGUgbm9kZSB0byBhIGNvbW1lbnQgbm9kZS5cclxuICAgKiBAc2VlIGBSZW5kZXJlcjIjY3JlYXRlQ29tbWVudGAuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gdmFsdWUgdGhlIHRleHQgaW4gdGhlIGNvbW1lbnQgdG8gcmVuZGVyLlxyXG4gICAqIEByZXR1cm5zIGl0c2VsZi5cclxuICAgKi9cclxuICBhc0NvbW1lbnQodmFsdWU6IHN0cmluZykge1xyXG4gICAgdGhpcy5zZXRSZW5kZXJQZW5kaW5nKCk7XHJcbiAgICB0aGlzLnR5cGUgPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLl9jb21tZW50ID0gdmFsdWU7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENhc3QgdGhlIG5vZGUgdG8gYSB0ZXh0IG5vZGUuXHJcbiAgICogQHNlZSBgUmVuZGVyZXIyI2NyZWF0ZVRleHRgLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHZhbHVlIHRoZSB0ZXh0IHRvIHJlbmRlci5cclxuICAgKiBAcmV0dXJucyBpdHNlbGYuXHJcbiAgICovXHJcbiAgYXNUZXh0KHZhbHVlOiBzdHJpbmcpIHtcclxuICAgIHRoaXMuc2V0UmVuZGVyUGVuZGluZygpO1xyXG4gICAgdGhpcy50eXBlID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5fdGV4dCA9IHZhbHVlO1xyXG5cclxuICAgIC8vIFNraXAgYXBwZW5kaW5nIGFuZCByZW5kZXJpbmcgb2YgZW1wdHkgdGV4dCBub2Rlcy4gVGhpcyBtYXkgY2F1c2UgYSBidWdcclxuICAgIC8vIGlmIGEgc2luZ2xlIHNwYWNlIGlzIGRlc2lyZWQuLi5cclxuICAgIGlmICghdmFsdWUgfHwgIXZhbHVlLnRyaW0oKSkge1xyXG4gICAgICB0aGlzLl9pc05vdFJlbmRlcmFibGUgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVuZGVyIHRoZSBub2RlIHRvIHRoZSBET00sIG9yIHVubW91bnQgaXQsIGFzIG5lY2Vzc2FyeS5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIGl0c2VsZi5cclxuICAgKi9cclxuICByZW5kZXIoKTogUmVhY3ROb2RlIHtcclxuICAgIC8vIE9ubHkgY29tcGxldGUgcmVuZGVyIG9wZXJhdGlvbnMgZm9yIFJlYWN0Tm9kZXMgdGhhdCBhcmUgcGFyZW50ZWQgYnkgSFRNTEVsZW1lbnRzLlxyXG4gICAgLy8gVGhvc2UgdGhhdCBhcmUgcGFyZW50ZWQgYnkgb3RoZXIgUmVhY3ROb2RlcyB3aWxsIGJlIHJlbmRlcmVkIHJlY3Vyc2l2ZWx5IGJ5IHRoZWlyXHJcbiAgICAvLyBwYXJlbnQuXHJcbiAgICBpZiAoIWlzUmVhY3ROb2RlKHRoaXMuX3BhcmVudCkpIHtcclxuICAgICAgaWYgKHRoaXMuX2lzRGVzdHJveVBlbmRpbmcgJiYgdGhpcy5fcGFyZW50KSB7XHJcbiAgICAgICAgaWYgKERFQlVHKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZygnUmVhY3ROb2RlID4gcmVuZGVyID4gZGVzdHJveSA+IG5vZGU6JywgdGhpcy50b1N0cmluZygpLCAncGFyZW50OicsIHRoaXMucGFyZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgUmVhY3RET00udW5tb3VudENvbXBvbmVudEF0Tm9kZSh0aGlzLl9wYXJlbnQpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodGhpcy5faXNSZW5kZXJQZW5kaW5nKSB7XHJcbiAgICAgICAgaWYgKERFQlVHKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZygnUmVhY3ROb2RlID4gcmVuZGVyID4gbm9kZTonLCB0aGlzLnRvU3RyaW5nKCksICdwYXJlbnQ6JywgdGhpcy5wYXJlbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJdCBpcyBleHBlY3RlZCB0aGF0IHRoZSBlbGVtZW50IHdpbGwgYmUgcmVjcmVhdGVkIGFuZCByZS1yZW5kZXJlZCB3aXRoIGVhY2ggYXR0cmlidXRlIGNoYW5nZS5cclxuICAgICAgICAvLyBTZWU6IGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZW5kZXJpbmctZWxlbWVudHMuaHRtbFxyXG4gICAgICAgIFJlYWN0RE9NLnJlbmRlcih0aGlzLl9yZW5kZXJSZWN1cnNpdmUoKSBhcyBSZWFjdC5SZWFjdEVsZW1lbnQ8e30+LCB0aGlzLl9wYXJlbnQpO1xyXG4gICAgICAgIHRoaXMuX2lzUmVuZGVyUGVuZGluZyA9IGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBcHBlbmRzIGEgY2hpbGQuXHJcbiAgICpcclxuICAgKiBAc2VlIGBSZW5kZXJlcjIjYXBwZW5kQ2hpbGRgLlxyXG4gICAqIEBub3RlIFRoaXMgaXMgY2FsbGVkIGJ5IEFuZ3VsYXIgY29yZSB3aGVuIHByb2plY3RlZCBjb250ZW50IGlzIGJlaW5nIGFkZGVkLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHByb2plY3RlZENvbnRlbnQgdGhlIGNvbnRlbnQgdG8gcHJvamVjdC5cclxuICAgKi9cclxuICBhcHBlbmRDaGlsZChwcm9qZWN0ZWRDb250ZW50OiBIVE1MRWxlbWVudCkge1xyXG4gICAgaWYgKERFQlVHKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoXHJcbiAgICAgICAgJ1JlYWN0Tm9kZSA+IGFwcGVuZENoaWxkID4gbm9kZTonLFxyXG4gICAgICAgIHRoaXMudG9TdHJpbmcoKSxcclxuICAgICAgICAncHJvamVjdGVkQ29udGVudDonLFxyXG4gICAgICAgIHByb2plY3RlZENvbnRlbnQudG9TdHJpbmcoKS50cmltKClcclxuICAgICAgKTtcclxuICAgIH1cclxuICAgIHRoaXMuX2NoaWxkcmVuVG9BcHBlbmQucHVzaChwcm9qZWN0ZWRDb250ZW50KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBub3RlIGZvciBlYXNpZXIgZGVidWdnaW5nLlxyXG4gICAqL1xyXG4gIHRvU3RyaW5nKCk6IHN0cmluZyB7XHJcbiAgICBpZiAodGhpcy5fdHlwZU5hbWUpIHtcclxuICAgICAgcmV0dXJuIGBbJHt0aGlzLl90eXBlTmFtZX0gUmVhY3ROb2RlXWA7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuX3RleHQpIHtcclxuICAgICAgcmV0dXJuICdbdGV4dCBSZWFjdE5vZGVdJztcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5fY29tbWVudCkge1xyXG4gICAgICByZXR1cm4gJ1tjb21tZW50IFJlYWN0Tm9kZV0nO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAnW3VuZGVmaW5lZCBSZWFjdE5vZGVdJztcclxuICB9XHJcblxyXG4gIHByaXZhdGUgX3JlbmRlclJlY3Vyc2l2ZShrZXk/OiBzdHJpbmcpOiBSZWFjdC5SZWFjdEVsZW1lbnQ8e30+IHwgc3RyaW5nIHtcclxuICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW5cclxuICAgICAgPyB0aGlzLl9jaGlsZHJlbi5tYXAoKGNoaWxkLCBpbmRleCkgPT4gY2hpbGQuX3JlbmRlclJlY3Vyc2l2ZShpbmRleC50b1N0cmluZygpKSlcclxuICAgICAgOiBbXTtcclxuXHJcbiAgICBpZiAodGhpcy5fdGV4dCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5fdGV4dDtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9wcm9wc1tDSElMRFJFTl9UT19BUFBFTkRfUFJPUF0gPSB0aGlzLl9jaGlsZHJlblRvQXBwZW5kO1xyXG5cclxuICAgIGlmIChrZXkpIHtcclxuICAgICAgdGhpcy5fcHJvcHNbJ2tleSddID0ga2V5O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEp1c3QgaGF2aW5nIHNvbWUgcHJvcHMgb24gYSBSZWFjdCBlbGVtZW50IGNhbiBjYXVzZSBpdCB0b1xyXG4gICAgLy8gYmVoYXZlIHVuZGVzaXJhYmx5LCBhbmQgc2luY2UgdGhlIHRlbXBsYXRlcyBhcmUgaGFyZC1jb2RlZCB0byBwYXNzXHJcbiAgICAvLyBhbGwgSW5wdXRzIGFsbCB0aGUgdGltZSwgdGhleSBwYXNzIGB1bmRlZmluZWRgIHZhbHVlcyB0b28uXHJcbiAgICAvLyBUaGlzIGVuc3VyZXMgdGhlc2UgYXJlIHJlbW92ZWQuXHJcbiAgICAvLyBBZGRpdGlvbmFsbHksIHRoZXJlIGFyZSBzb21lIHRoaW5ncyB0aGF0IEFuZ3VsYXIgdGVtcGxhdGluZyBmb3JiaWRzLFxyXG4gICAgLy8gYW5kIHN0b3BzIGF0LWNvbXBpbGUgdGltZSAod2l0aCBlcnJvcnMpLCBzdWNoIGFzIGBJbnB1dGBzIGJlaW5nIHByZWZpeGVkIHdpdGggYG9uYC5cclxuICAgIC8vIFNpbmNlIFJlYWN0IGRvZXMgbm90IGhhdmUgdGhlIG5vdGlvbiBvZiBgT3V0cHV0YHMgYXMgQW5ndWxhciAodGhleSBhcmUganVzdCBwcm9wcyBvZiB0eXBlIGZ1bmN0aW9uLCBlc3NlbnRpYWxseSBjYWxsYmFja3MpLlxyXG4gICAgLy8gVG8gd29yayBhcm91bmQgdGhpcywgd2UsIGJ5IGNvbnZlbnRpb24sIHByZWZpeCBhbnkgUGFzY2FsQ2FzZWQgcHJvcCB3aXRoIGBvbmAgaGVyZSwgYWZ0ZXIgdGhlIHRlbXBsYXRlIGhhcyBhbHJlYWR5IGJlZW4gY29tcGlsZWQuXHJcbiAgICBjb25zdCBjbGVhcmVkUHJvcHMgPSB0aGlzLl90cmFuc2Zvcm1Qcm9wcyhyZW1vdmVVbmRlZmluZWRQcm9wZXJ0aWVzKHRoaXMuX3Byb3BzKSk7XHJcblxyXG4gICAgaWYgKERFQlVHKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihcclxuICAgICAgICAnUmVhY3ROb2RlID4gcmVuZGVyUmVjdXJzaXZlID4gdHlwZTonLFxyXG4gICAgICAgIHRoaXMudG9TdHJpbmcoKSxcclxuICAgICAgICAncHJvcHM6JyxcclxuICAgICAgICB0aGlzLl9wcm9wcyxcclxuICAgICAgICAnY2hpbGRyZW46JyxcclxuICAgICAgICBjaGlsZHJlblxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQodGhpcy50eXBlLCBjbGVhcmVkUHJvcHMsIGNoaWxkcmVuLmxlbmd0aCA+IDAgPyBjaGlsZHJlbiA6IHVuZGVmaW5lZCk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIF90cmFuc2Zvcm1Qcm9wczxUUHJvcHMgZXh0ZW5kcyBvYmplY3Q+KHByb3BzOiBUUHJvcHMpIHtcclxuICAgIHJldHVybiBPYmplY3QuZW50cmllcyhwcm9wcykucmVkdWNlKChhY2MsIFtrZXksIHZhbHVlXSkgPT4ge1xyXG4gICAgICBjb25zdCBbbmV3S2V5LCBuZXdWYWx1ZV0gPSB0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJyA/IFtrZXksIHZhbHVlXSA6IHRoaXMuX3RyYW5zZm9ybVByb3Aoa2V5LCB2YWx1ZSk7XHJcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKGFjYywgeyBbbmV3S2V5XTogbmV3VmFsdWUgfSk7XHJcbiAgICB9LCB7fSk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIF90cmFuc2Zvcm1Qcm9wPFRWYWx1ZSA9IGFueT4obmFtZTogc3RyaW5nLCB2YWx1ZTogVFZhbHVlKTogW3N0cmluZywgVFZhbHVlXSB7XHJcbiAgICAvLyBwcm9wIG5hbWUgaXMgY2FtZWxDYXNlZCBhbHJlYWR5XHJcbiAgICBjb25zdCBmaXJzdExldHRlciA9IG5hbWVbMF07XHJcbiAgICBpZiAoZmlyc3RMZXR0ZXIgPT09IGZpcnN0TGV0dGVyLnRvTG93ZXJDYXNlKCkpIHtcclxuICAgICAgcmV0dXJuIFtuYW1lLCB2YWx1ZV07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gcHJvcCBuYW1lIGlzIFBhc2NhbENhc2VkICYgaXMgYSBmdW5jdGlvbiAtIGFzc3VtaW5nIHJlbmRlciBwcm9wIG9yIGNhbGxiYWNrIHByb3AgdGhhdCBoYXMgcmV0dXJuIHZhbHVlXHJcbiAgICAvLyBOT1RFOiBBbmd1bGFyIGRvZXNuJ3QgYWxsb3cgcGFzc2luZyBASW5wdXRzIHRoYXQgYXJlIHByZWZpeGVkIHdpdGggXCJvblwiLiBUaGlzIGlzIHVzZWZ1bCBmb3IgcmVuZGVyIHByb3BzIGFuZCBwcm9wZXJ0aWVzIHJlcHJlc2VudGluZyB0aGUgXCJvblwiIHN0YXRlIChmb3IgZXhhbXBsZSwgVG9nZ2xlKS5cclxuICAgIC8vIEFzIGEgY29udmVudGlvbiwgYW55IEBJbnB1dCB0aGF0IHN0YXJ0cyB3aXRoIGEgY2FwaXRhbCBsZXR0ZXIgaXMgcHJlZml4ZWQgd2l0aCBcIm9uXCIgd2hlbiBwYXNzZWQgYXMgYSBwcm9wIHRvIHRoZSB1bmRlcmx5aW5nIFJlYWN0IGNvbXBvbmVudC5cclxuICAgIHJldHVybiBbYG9uJHtuYW1lfWAsIHZhbHVlXTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgX3RyeVJlc29sdmVUeXBlSXNSZWFjdEVsZW1lbnRDbGFzcygpIHtcclxuICAgIGlmICh0aGlzLl90eXBlSXNSZWFjdEVsZW1lbnRDbGFzcyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIC8vIENvbW1lbnRzIGFuZCB0ZXh0IGhhdmUgbm8gdHlwZS5cclxuICAgICAgaWYgKCF0aGlzLnR5cGUpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFN0b3JlIHRoZSBuYW1lIG9mIHRoZSB0eXBlIGZvciB0aGUgdG9TdHJpbmcgbWVzc2FnZSAoZGVidWdnaW5nKS5cclxuICAgICAgdGhpcy5fdHlwZU5hbWUgPSB0aGlzLnR5cGUgYXMgc3RyaW5nO1xyXG5cclxuICAgICAgLy8gQXR0ZW1wdCB0byByZXNvbHZlIHRoZSB0eXBlIGFzIGEgUmVhY3QgRWxlbWVudCBjbGFzcyBuYW1lL3R5cGUuXHJcbiAgICAgIC8vIFNpbmNlIEFuZ3VsYXIgdGVtcGxhdGVzIGFyZSBqdXN0IHN0cmluZ3MsIHdlIGNhbid0IGluY2x1ZGUgdHlwZXMgaW4gdGhlbS5cclxuICAgICAgLy8gVGhlcmVmb3JlLCB3ZSB1c2UgdGhlIGNvbXBvbmVudCByZWdpc3RyeSB0byByZXNvbHZlIHRoZSB0eXBlIG9mIGEgY29tcG9uZW50IGZyb20gYSBzdHJpbmcuXHJcbiAgICAgIGlmICh0eXBlb2YgdGhpcy50eXBlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHRoaXMudHlwZSA9IGdldENvbXBvbmVudENsYXNzKHRoaXMudHlwZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIElmIHR5cGUgaXMgc3RpbGwgYSBzdHJpbmcsIHRoZW4gbm8gUmVhY3QgRWxlbWVudCBtYXRjaGVzIHRoaXMgc3RyaW5nLlxyXG4gICAgICB0aGlzLl90eXBlSXNSZWFjdEVsZW1lbnRDbGFzcyA9IHR5cGVvZiB0aGlzLnR5cGUgIT09ICdzdHJpbmcnO1xyXG5cclxuICAgICAgaWYgKERFQlVHKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ1JlYWN0Tm9kZSA+IHRyeVJlc29sdmVUeXBlSXNSZWFjdEVsZW1lbnRDbGFzcyA+IHR5cGU6JywgdGhpcy5fdHlwZU5hbWUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbiJdfQ==