// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
/// <reference path="../@types/geteventlisteners.d.ts" />
import * as tslib_1 from "tslib";
import { Input, } from '@angular/core';
import classnames from 'classnames';
import toStyle from 'css-to-style';
import stylenames from 'stylenames';
import { isReactNode } from '../renderer/react-node';
import { isReactRendererData } from '../renderer/renderer';
import { toObject } from '../utils/object/to-object';
import { afterRenderFinished } from '../utils/render/render-delay';
import { createInputJsxRenderer, createRenderPropHandler } from './render-props';
// Forbidden attributes are still ignored, since they may be set from the wrapper components themselves (forbidden is only applied for users of the wrapper components)
const ignoredAttributeMatchers = [/^_?ng-?.*/, /^style$/, /^class$/];
const ngClassRegExp = /^ng-/;
const defaultWrapperComponentOptions = {
    setHostDisplay: false,
};
/**
 * Base class for Angular @Components wrapping React Components.
 * Simplifies some of the handling around passing down props and CSS styling on the host component.
 */
// NOTE: TProps is not used at the moment, but a preparation for a potential future change.
export class ReactWrapperComponent {
    /**
     * Creates an instance of ReactWrapperComponent.
     * @param elementRef The host element.
     * @param changeDetectorRef The change detector for the component.
     * @param renderer The Angular renderer.
     */
    constructor(elementRef, changeDetectorRef, renderer, { setHostDisplay, ngZone } = defaultWrapperComponentOptions) {
        this.elementRef = elementRef;
        this.changeDetectorRef = changeDetectorRef;
        this.renderer = renderer;
        this._ngZone = ngZone;
        this._shouldSetHostDisplay = setHostDisplay;
    }
    /**
     * Alternative to `class` and `[ngClass]` using the same syntax.
     *
     * @description Since this is a wrapper component, sticking to the virtual DOM concept, its DOM element shouldn't have any styling of its own.
     * Instead, any value passes to `contentClass` will be passed to the root component's class as `className`.
     */
    set contentClass(value) {
        this._contentClass = value;
        if (isReactNode(this.reactNodeRef.nativeElement)) {
            this.reactNodeRef.nativeElement.setProperty('className', classnames(value));
            this.markForCheck();
        }
    }
    get contentClass() {
        return this._contentClass;
    }
    /**
     * Alternative to `style` and `[ngStyle]` using (almost) the same syntax.
     * All syntax supports by `ngStyle` is supported, with the exception of specifying units in the key (`{ 'width.px': 12 }`).
     *
     * @description Since this is a wrapper component, sticking to the virtual DOM concept, this should have any styling of its own.
     * Any value passes to `contentStyle` will be passed to the root component's style.
     */
    set contentStyle(value) {
        this._contentStyle = value;
        if (isReactNode(this.reactNodeRef.nativeElement)) {
            const stringValue = typeof value === 'string' ? value : stylenames(value);
            this.reactNodeRef.nativeElement.setProperty('style', toStyle(stringValue));
            this.markForCheck();
        }
    }
    get contentStyle() {
        return this._contentStyle;
    }
    ngAfterContentInit() {
        this._passAttributesAsProps();
    }
    ngAfterViewInit() {
        if (this._shouldSetHostDisplay) {
            this._setHostDisplay();
        }
        // NOTE: Workaround/fix for Issue #5 (https://github.com/Microsoft/angular-react/issues/5).
        // The wrapper component isn't added to the root react nodes list when it's inside a `ReactContent` node, we manually add it (note that the root nodes list is a `Set`, so it won't duplicate nodes if already exist).
        // There's potentially a better solution instead of this
        const rendererData = this.renderer.data;
        if (isReactRendererData(rendererData)) {
            afterRenderFinished(() => {
                const nativeElement = this.reactNodeRef.nativeElement;
                if (isReactNode(nativeElement)) {
                    rendererData.addRootNode(nativeElement);
                }
            });
        }
    }
    ngOnChanges(changes) {
        this._passAttributesAsProps();
        this.markForCheck();
    }
    /**
     * Mark the component as one that needed re-rendering on the React side,
     * and mark for change detection on the Angular side.
     */
    markForCheck() {
        if (isReactNode(this.reactNodeRef.nativeElement)) {
            this.reactNodeRef.nativeElement.setRenderPending();
        }
        this.changeDetectorRef.markForCheck();
    }
    /**
     * Create an JSX renderer for an `@Input` property.
     * @param input The input property.
     * @param additionalProps optional additional props to pass to the `ReactContent` object that will render the content.
     */
    createInputJsxRenderer(input, additionalProps) {
        if (input === undefined) {
            return undefined;
        }
        if (!this._ngZone) {
            throw new Error('To create an input JSX renderer you must pass an NgZone to the constructor.');
        }
        return createInputJsxRenderer(input, this._ngZone, additionalProps);
    }
    /**
     * Create an event handler for a render prop
     * @param renderInputValue the value of the render `@Input` property.
     * @param jsxRenderer an optional renderer to use.
     * @param additionalProps optional additional props to pass to the `ReactContent` object that will render the content.
     */
    createRenderPropHandler(renderInputValue, options) {
        return createRenderPropHandler(renderInputValue, this._ngZone, options);
    }
    _passAttributesAsProps() {
        const hostAttributes = Array.from(this.elementRef.nativeElement.attributes);
        if (!this.reactNodeRef || !isReactNode(this.reactNodeRef.nativeElement)) {
            throw new Error('reactNodeRef must hold a reference to a ReactNode');
        }
        // Ensure there are no blacklisted props. Suggest alternative as error if there is any
        hostAttributes.forEach(attr => {
            const [forbidden, alternativeAttrName] = this._isForbiddenAttribute(attr);
            if (forbidden) {
                throw new Error(`[${this.elementRef
                    .nativeElement.tagName.toLowerCase()}] React wrapper components cannot have the '${attr.name}' attribute set. Use the following alternative: ${alternativeAttrName || ''}`);
            }
        });
        const whitelistedHostAttributes = hostAttributes.filter(attr => !this._isIgnoredAttribute(attr));
        const props = whitelistedHostAttributes.reduce((acc, attr) => (Object.assign({}, acc, { [attr.name]: attr.value })), {});
        const eventListeners = this.elementRef.nativeElement.getEventListeners();
        const eventHandlersProps = eventListeners && Object.keys(eventListeners).length
            ? toObject(Object.values(eventListeners).map(([eventListener]) => [
                eventListener.type,
                (ev) => eventListener.listener(ev && ev.nativeEvent),
            ]))
            : {};
        {
        }
        this.reactNodeRef.nativeElement.setProperties(Object.assign({}, props, eventHandlersProps));
    }
    _setHostDisplay() {
        const nativeElement = this.elementRef.nativeElement;
        // We want to wait until child elements are rendered
        requestAnimationFrame(() => {
            if (nativeElement.firstElementChild) {
                const rootChildDisplay = getComputedStyle(nativeElement.firstElementChild).display;
                nativeElement.style.display = rootChildDisplay;
            }
        });
    }
    _isIgnoredAttribute(attr) {
        return ignoredAttributeMatchers.some(regExp => regExp.test(attr.name));
    }
    _isForbiddenAttribute(attr) {
        const { name, value } = attr;
        if (name === 'key')
            return [true, undefined];
        if (name === 'class' && value.split(' ').some(className => !ngClassRegExp.test(className)))
            return [true, 'contentClass'];
        if (name === 'style') {
            const style = toStyle(value);
            // Only allowing style if it's something that changes the display - setting anything else should be done on the child component directly (via the `styles` attribute in fabric for example)
            if (Object.entries(style).filter(([key, value]) => value && key !== 'display').length > 0) {
                return [true, 'contentStyle'];
            }
        }
        return [false, undefined];
    }
}
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Object),
    tslib_1.__metadata("design:paramtypes", [Object])
], ReactWrapperComponent.prototype, "contentClass", null);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Object),
    tslib_1.__metadata("design:paramtypes", [Object])
], ReactWrapperComponent.prototype, "contentStyle", null);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid3JhcHBlci1jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AYW5ndWxhci1yZWFjdC9jb3JlLyIsInNvdXJjZXMiOlsic3JjL2xpYi9jb21wb25lbnRzL3dyYXBwZXItY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLDREQUE0RDtBQUM1RCxrQ0FBa0M7QUFDbEMseURBQXlEOztBQUV6RCxPQUFPLEVBSUwsS0FBSyxHQU1OLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sVUFBVSxNQUFNLFlBQVksQ0FBQztBQUNwQyxPQUFPLE9BQU8sTUFBTSxjQUFjLENBQUM7QUFDbkMsT0FBTyxVQUEyQixNQUFNLFlBQVksQ0FBQztBQUlyRCxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sd0JBQXdCLENBQUM7QUFDckQsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFDM0QsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLDJCQUEyQixDQUFDO0FBQ3JELE9BQU8sRUFBRSxtQkFBbUIsRUFBRSxNQUFNLDhCQUE4QixDQUFDO0FBQ25FLE9BQU8sRUFBdUMsc0JBQXNCLEVBQUUsdUJBQXVCLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUV0SCx1S0FBdUs7QUFDdkssTUFBTSx3QkFBd0IsR0FBRyxDQUFDLFdBQVcsRUFBRSxTQUFTLEVBQUUsU0FBUyxDQUFDLENBQUM7QUFFckUsTUFBTSxhQUFhLEdBQUcsTUFBTSxDQUFDO0FBc0I3QixNQUFNLDhCQUE4QixHQUE0QjtJQUM5RCxjQUFjLEVBQUUsS0FBSztDQUN0QixDQUFDO0FBRUY7OztHQUdHO0FBQ0gsMkZBQTJGO0FBQzNGLE1BQU0sT0FBZ0IscUJBQXFCO0lBaUR6Qzs7Ozs7T0FLRztJQUNILFlBQ2tCLFVBQW1DLEVBQ2xDLGlCQUFvQyxFQUNwQyxRQUFtQixFQUNwQyxFQUFFLGNBQWMsRUFBRSxNQUFNLEtBQThCLDhCQUE4QjtRQUhwRSxlQUFVLEdBQVYsVUFBVSxD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REMsS0FBSyxFQUFFOzs7eURBUVAiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vQHR5cGVzL2dldGV2ZW50bGlzdGVuZXJzLmQudHNcIiAvPlxyXG5cclxuaW1wb3J0IHtcclxuICBBZnRlclZpZXdJbml0LFxyXG4gIENoYW5nZURldGVjdG9yUmVmLFxyXG4gIEVsZW1lbnRSZWYsXHJcbiAgSW5wdXQsXHJcbiAgTmdab25lLFxyXG4gIE9uQ2hhbmdlcyxcclxuICBSZW5kZXJlcjIsXHJcbiAgU2ltcGxlQ2hhbmdlcyxcclxuICBBZnRlckNvbnRlbnRJbml0LFxyXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuaW1wb3J0IHRvU3R5bGUgZnJvbSAnY3NzLXRvLXN0eWxlJztcclxuaW1wb3J0IHN0eWxlbmFtZXMsIHsgU3R5bGVPYmplY3QgfSBmcm9tICdzdHlsZW5hbWVzJztcclxuXHJcbmltcG9ydCB7IE1hbnkgfSBmcm9tICcuLi9kZWNsYXJhdGlvbnMvbWFueSc7XHJcbmltcG9ydCB7IFJlYWN0Q29udGVudFByb3BzIH0gZnJvbSAnLi4vcmVuZGVyZXIvcmVhY3QtY29udGVudCc7XHJcbmltcG9ydCB7IGlzUmVhY3ROb2RlIH0gZnJvbSAnLi4vcmVuZGVyZXIvcmVhY3Qtbm9kZSc7XHJcbmltcG9ydCB7IGlzUmVhY3RSZW5kZXJlckRhdGEgfSBmcm9tICcuLi9yZW5kZXJlci9yZW5kZXJlcic7XHJcbmltcG9ydCB7IHRvT2JqZWN0IH0gZnJvbSAnLi4vdXRpbHMvb2JqZWN0L3RvLW9iamVjdCc7XHJcbmltcG9ydCB7IGFmdGVyUmVuZGVyRmluaXNoZWQgfSBmcm9tICcuLi91dGlscy9yZW5kZXIvcmVuZGVyLWRlbGF5JztcclxuaW1wb3J0IHsgSW5wdXRSZW5kZXJlck9wdGlvbnMsIEpzeFJlbmRlckZ1bmMsIGNyZWF0ZUlucHV0SnN4UmVuZGVyZXIsIGNyZWF0ZVJlbmRlclByb3BIYW5kbGVyIH0gZnJvbSAnLi9yZW5kZXItcHJvcHMnO1xyXG5cclxuLy8gRm9yYmlkZGVuIGF0dHJpYnV0ZXMgYXJlIHN0aWxsIGlnbm9yZWQsIHNpbmNlIHRoZXkgbWF5IGJlIHNldCBmcm9tIHRoZSB3cmFwcGVyIGNvbXBvbmVudHMgdGhlbXNlbHZlcyAoZm9yYmlkZGVuIGlzIG9ubHkgYXBwbGllZCBmb3IgdXNlcnMgb2YgdGhlIHdyYXBwZXIgY29tcG9uZW50cylcclxuY29uc3QgaWdub3JlZEF0dHJpYnV0ZU1hdGNoZXJzID0gWy9eXz9uZy0/LiovLCAvXnN0eWxlJC8sIC9eY2xhc3MkL107XHJcblxyXG5jb25zdCBuZ0NsYXNzUmVnRXhwID0gL15uZy0vO1xyXG5cclxuZXhwb3J0IHR5cGUgQ29udGVudENsYXNzVmFsdWUgPSBzdHJpbmdbXSB8IFNldDxzdHJpbmc+IHwgeyBba2xhc3M6IHN0cmluZ106IGFueSB9O1xyXG5leHBvcnQgdHlwZSBDb250ZW50U3R5bGVWYWx1ZSA9IHN0cmluZyB8IFN0eWxlT2JqZWN0O1xyXG5cclxuLyoqXHJcbiAqIE9wdGlvbmFsIG9wdGlvbnMgdG8gcGFzcyB0byBgUmVhY3RXcmFwcGVyQ29tcG9uZW50YC5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgV3JhcHBlckNvbXBvbmVudE9wdGlvbnMge1xyXG4gIC8qKlxyXG4gICAqIFdoZXRoZXIgdGhlIGhvc3QncyBgZGlzcGxheWAgc2hvdWxkIGJlIHNldCB0byB0aGUgcm9vdCBjaGlsZCBub2RlJ3NgZGlzcGxheWAuXHJcbiAgICogQGRlZmF1bHQgYGZhbHNlYC5cclxuICAgKi9cclxuICByZWFkb25seSBzZXRIb3N0RGlzcGxheT86IGJvb2xlYW47XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSB6b25lIHRvIHVzZSB0byB0cmFjayBjaGFuZ2VzIHRvIGlubmVyIChBbmd1bGFyKSB0ZW1wbGF0ZXMgJiBjb21wb25lbnRzLlxyXG4gICAqIEBkZWZhdWx0IGB1bmRlZmluZWRgLlxyXG4gICAqL1xyXG4gIHJlYWRvbmx5IG5nWm9uZT86IE5nWm9uZTtcclxufVxyXG5cclxuY29uc3QgZGVmYXVsdFdyYXBwZXJDb21wb25lbnRPcHRpb25zOiBXcmFwcGVyQ29tcG9uZW50T3B0aW9ucyA9IHtcclxuICBzZXRIb3N0RGlzcGxheTogZmFsc2UsXHJcbn07XHJcblxyXG4vKipcclxuICogQmFzZSBjbGFzcyBmb3IgQW5ndWxhciBAQ29tcG9uZW50cyB3cmFwcGluZyBSZWFjdCBDb21wb25lbnRzLlxyXG4gKiBTaW1wbGlmaWVzIHNvbWUgb2YgdGhlIGhhbmRsaW5nIGFyb3VuZCBwYXNzaW5nIGRvd24gcHJvcHMgYW5kIENTUyBzdHlsaW5nIG9uIHRoZSBob3N0IGNvbXBvbmVudC5cclxuICovXHJcbi8vIE5PVEU6IFRQcm9wcyBpcyBub3QgdXNlZCBhdCB0aGUgbW9tZW50LCBidXQgYSBwcmVwYXJhdGlvbiBmb3IgYSBwb3RlbnRpYWwgZnV0dXJlIGNoYW5nZS5cclxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFJlYWN0V3JhcHBlckNvbXBvbmVudDxUUHJvcHMgZXh0ZW5kcyB7fT4gaW1wbGVtZW50cyBBZnRlckNvbnRlbnRJbml0LCBBZnRlclZpZXdJbml0LCBPbkNoYW5nZXMge1xyXG4gIHByaXZhdGUgX2NvbnRlbnRDbGFzczogTWFueTxDb250ZW50Q2xhc3NWYWx1ZT47XHJcbiAgcHJpdmF0ZSBfY29udGVudFN0eWxlOiBDb250ZW50U3R5bGVWYWx1ZTtcclxuXHJcbiAgcHJpdmF0ZSBfbmdab25lOiBOZ1pvbmU7XHJcbiAgcHJpdmF0ZSBfc2hvdWxkU2V0SG9zdERpc3BsYXk6IGJvb2xlYW47XHJcblxyXG4gIHByb3RlY3RlZCBhYnN0cmFjdCByZWFjdE5vZGVSZWY6IEVsZW1lbnRSZWY8SFRNTEVsZW1lbnQ+O1xyXG5cclxuICAvKipcclxuICAgKiBBbHRlcm5hdGl2ZSB0byBgY2xhc3NgIGFuZCBgW25nQ2xhc3NdYCB1c2luZyB0aGUgc2FtZSBzeW50YXguXHJcbiAgICpcclxuICAgKiBAZGVzY3JpcHRpb24gU2luY2UgdGhpcyBpcyBhIHdyYXBwZXIgY29tcG9uZW50LCBzdGlja2luZyB0byB0aGUgdmlydHVhbCBET00gY29uY2VwdCwgaXRzIERPTSBlbGVtZW50IHNob3VsZG4ndCBoYXZlIGFueSBzdHlsaW5nIG9mIGl0cyBvd24uXHJcbiAgICogSW5zdGVhZCwgYW55IHZhbHVlIHBhc3NlcyB0byBgY29udGVudENsYXNzYCB3aWxsIGJlIHBhc3NlZCB0byB0aGUgcm9vdCBjb21wb25lbnQncyBjbGFzcyBhcyBgY2xhc3NOYW1lYC5cclxuICAgKi9cclxuICBASW5wdXQoKVxyXG4gIHNldCBjb250ZW50Q2xhc3ModmFsdWU6IE1hbnk8Q29udGVudENsYXNzVmFsdWU+KSB7XHJcbiAgICB0aGlzLl9jb250ZW50Q2xhc3MgPSB2YWx1ZTtcclxuICAgIGlmIChpc1JlYWN0Tm9kZSh0aGlzLnJlYWN0Tm9kZVJlZi5uYXRpdmVFbGVtZW50KSkge1xyXG4gICAgICB0aGlzLnJlYWN0Tm9kZVJlZi5uYXRpdmVFbGVtZW50LnNldFByb3BlcnR5KCdjbGFzc05hbWUnLCBjbGFzc25hbWVzKHZhbHVlKSk7XHJcbiAgICAgIHRoaXMubWFya0ZvckNoZWNrKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBnZXQgY29udGVudENsYXNzKCk6IE1hbnk8Q29udGVudENsYXNzVmFsdWU+IHtcclxuICAgIHJldHVybiB0aGlzLl9jb250ZW50Q2xhc3M7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBbHRlcm5hdGl2ZSB0byBgc3R5bGVgIGFuZCBgW25nU3R5bGVdYCB1c2luZyAoYWxtb3N0KSB0aGUgc2FtZSBzeW50YXguXHJcbiAgICogQWxsIHN5bnRheCBzdXBwb3J0cyBieSBgbmdTdHlsZWAgaXMgc3VwcG9ydGVkLCB3aXRoIHRoZSBleGNlcHRpb24gb2Ygc3BlY2lmeWluZyB1bml0cyBpbiB0aGUga2V5IChgeyAnd2lkdGgucHgnOiAxMiB9YCkuXHJcbiAgICpcclxuICAgKiBAZGVzY3JpcHRpb24gU2luY2UgdGhpcyBpcyBhIHdyYXBwZXIgY29tcG9uZW50LCBzdGlja2luZyB0byB0aGUgdmlydHVhbCBET00gY29uY2VwdCwgdGhpcyBzaG91bGQgaGF2ZSBhbnkgc3R5bGluZyBvZiBpdHMgb3duLlxyXG4gICAqIEFueSB2YWx1ZSBwYXNzZXMgdG8gYGNvbnRlbnRTdHlsZWAgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIHJvb3QgY29tcG9uZW50J3Mgc3R5bGUuXHJcbiAgICovXHJcbiAgQElucHV0KClcclxuICBzZXQgY29udGVudFN0eWxlKHZhbHVlOiBDb250ZW50U3R5bGVWYWx1ZSkge1xyXG4gICAgdGhpcy5fY29udGVudFN0eWxlID0gdmFsdWU7XHJcbiAgICBpZiAoaXNSZWFjdE5vZGUodGhpcy5yZWFjdE5vZGVSZWYubmF0aXZlRWxlbWVudCkpIHtcclxuICAgICAgY29uc3Qgc3RyaW5nVmFsdWUgPSB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gdmFsdWUgOiBzdHlsZW5hbWVzKHZhbHVlKTtcclxuICAgICAgdGhpcy5yZWFjdE5vZGVSZWYubmF0aXZlRWxlbWVudC5zZXRQcm9wZXJ0eSgnc3R5bGUnLCB0b1N0eWxlKHN0cmluZ1ZhbHVlKSk7XHJcbiAgICAgIHRoaXMubWFya0ZvckNoZWNrKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBnZXQgY29udGVudFN0eWxlKCk6IENvbnRlbnRTdHlsZVZhbHVlIHtcclxuICAgIHJldHVybiB0aGlzLl9jb250ZW50U3R5bGU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIFJlYWN0V3JhcHBlckNvbXBvbmVudC5cclxuICAgKiBAcGFyYW0gZWxlbWVudFJlZiBUaGUgaG9zdCBlbGVtZW50LlxyXG4gICAqIEBwYXJhbSBjaGFuZ2VEZXRlY3RvclJlZiBUaGUgY2hhbmdlIGRldGVjdG9yIGZvciB0aGUgY29tcG9uZW50LlxyXG4gICAqIEBwYXJhbSByZW5kZXJlciBUaGUgQW5ndWxhciByZW5kZXJlci5cclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihcclxuICAgIHB1YmxpYyByZWFkb25seSBlbGVtZW50UmVmOiBFbGVtZW50UmVmPEhUTUxFbGVtZW50PixcclxuICAgIHByaXZhdGUgcmVhZG9ubHkgY2hhbmdlRGV0ZWN0b3JSZWY6IENoYW5nZURldGVjdG9yUmVmLFxyXG4gICAgcHJpdmF0ZSByZWFkb25seSByZW5kZXJlcjogUmVuZGVyZXIyLFxyXG4gICAgeyBzZXRIb3N0RGlzcGxheSwgbmdab25lIH06IFdyYXBwZXJDb21wb25lbnRPcHRpb25zID0gZGVmYXVsdFdyYXBwZXJDb21wb25lbnRPcHRpb25zXHJcbiAgKSB7XHJcbiAgICB0aGlzLl9uZ1pvbmUgPSBuZ1pvbmU7XHJcbiAgICB0aGlzLl9zaG91bGRTZXRIb3N0RGlzcGxheSA9IHNldEhvc3REaXNwbGF5O1xyXG4gIH1cclxuXHJcbiAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xyXG4gICAgdGhpcy5fcGFzc0F0dHJpYnV0ZXNBc1Byb3BzKCk7XHJcbiAgfVxyXG5cclxuICBuZ0FmdGVyVmlld0luaXQoKSB7XHJcbiAgICBpZiAodGhpcy5fc2hvdWxkU2V0SG9zdERpc3BsYXkpIHtcclxuICAgICAgdGhpcy5fc2V0SG9zdERpc3BsYXkoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBOT1RFOiBXb3JrYXJvdW5kL2ZpeCBmb3IgSXNzdWUgIzUgKGh0dHBzOi8vZ2l0aHViLmNvbS9NaWNyb3NvZnQvYW5ndWxhci1yZWFjdC9pc3N1ZXMvNSkuXHJcbiAgICAvLyBUaGUgd3JhcHBlciBjb21wb25lbnQgaXNuJ3QgYWRkZWQgdG8gdGhlIHJvb3QgcmVhY3Qgbm9kZXMgbGlzdCB3aGVuIGl0J3MgaW5zaWRlIGEgYFJlYWN0Q29udGVudGAgbm9kZSwgd2UgbWFudWFsbHkgYWRkIGl0IChub3RlIHRoYXQgdGhlIHJvb3Qgbm9kZXMgbGlzdCBpcyBhIGBTZXRgLCBzbyBpdCB3b24ndCBkdXBsaWNhdGUgbm9kZXMgaWYgYWxyZWFkeSBleGlzdCkuXHJcbiAgICAvLyBUaGVyZSdzIHBvdGVudGlhbGx5IGEgYmV0dGVyIHNvbHV0aW9uIGluc3RlYWQgb2YgdGhpc1xyXG4gICAgY29uc3QgcmVuZGVyZXJEYXRhID0gdGhpcy5yZW5kZXJlci5kYXRhO1xyXG4gICAgaWYgKGlzUmVhY3RSZW5kZXJlckRhdGEocmVuZGVyZXJEYXRhKSkge1xyXG4gICAgICBhZnRlclJlbmRlckZpbmlzaGVkKCgpID0+IHtcclxuICAgICAgICBjb25zdCBuYXRpdmVFbGVtZW50ID0gdGhpcy5yZWFjdE5vZGVSZWYubmF0aXZlRWxlbWVudDtcclxuICAgICAgICBpZiAoaXNSZWFjdE5vZGUobmF0aXZlRWxlbWVudCkpIHtcclxuICAgICAgICAgIHJlbmRlcmVyRGF0YS5hZGRSb290Tm9kZShuYXRpdmVFbGVtZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcykge1xyXG4gICAgdGhpcy5fcGFzc0F0dHJpYnV0ZXNBc1Byb3BzKCk7XHJcblxyXG4gICAgdGhpcy5tYXJrRm9yQ2hlY2soKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1hcmsgdGhlIGNvbXBvbmVudCBhcyBvbmUgdGhhdCBuZWVkZWQgcmUtcmVuZGVyaW5nIG9uIHRoZSBSZWFjdCBzaWRlLFxyXG4gICAqIGFuZCBtYXJrIGZvciBjaGFuZ2UgZGV0ZWN0aW9uIG9uIHRoZSBBbmd1bGFyIHNpZGUuXHJcbiAgICovXHJcbiAgcHJvdGVjdGVkIG1hcmtGb3JDaGVjaygpIHtcclxuICAgIGlmIChpc1JlYWN0Tm9kZSh0aGlzLnJlYWN0Tm9kZVJlZi5uYXRpdmVFbGVtZW50KSkge1xyXG4gICAgICB0aGlzLnJlYWN0Tm9kZVJlZi5uYXRpdmVFbGVtZW50LnNldFJlbmRlclBlbmRpbmcoKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmNoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlIGFuIEpTWCByZW5kZXJlciBmb3IgYW4gYEBJbnB1dGAgcHJvcGVydHkuXHJcbiAgICogQHBhcmFtIGlucHV0IFRoZSBpbnB1dCBwcm9wZXJ0eS5cclxuICAgKiBAcGFyYW0gYWRkaXRpb25hbFByb3BzIG9wdGlvbmFsIGFkZGl0aW9uYWwgcHJvcHMgdG8gcGFzcyB0byB0aGUgYFJlYWN0Q29udGVudGAgb2JqZWN0IHRoYXQgd2lsbCByZW5kZXIgdGhlIGNvbnRlbnQuXHJcbiAgICovXHJcbiAgcHJvdGVjdGVkIGNyZWF0ZUlucHV0SnN4UmVuZGVyZXI8VENvbnRleHQgZXh0ZW5kcyBvYmplY3Q+KFxyXG4gICAgaW5wdXQ6IElucHV0UmVuZGVyZXJPcHRpb25zPFRDb250ZXh0PixcclxuICAgIGFkZGl0aW9uYWxQcm9wcz86IFJlYWN0Q29udGVudFByb3BzXHJcbiAgKTogSnN4UmVuZGVyRnVuYzxUQ29udGV4dD4gfCB1bmRlZmluZWQge1xyXG4gICAgaWYgKGlucHV0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXRoaXMuX25nWm9uZSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RvIGNyZWF0ZSBhbiBpbnB1dCBKU1ggcmVuZGVyZXIgeW91IG11c3QgcGFzcyBhbiBOZ1pvbmUgdG8gdGhlIGNvbnN0cnVjdG9yLicpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjcmVhdGVJbnB1dEpzeFJlbmRlcmVyKGlucHV0LCB0aGlzLl9uZ1pvbmUsIGFkZGl0aW9uYWxQcm9wcyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGUgYW4gZXZlbnQgaGFuZGxlciBmb3IgYSByZW5kZXIgcHJvcFxyXG4gICAqIEBwYXJhbSByZW5kZXJJbnB1dFZhbHVlIHRoZSB2YWx1ZSBvZiB0aGUgcmVuZGVyIGBASW5wdXRgIHByb3BlcnR5LlxyXG4gICAqIEBwYXJhbSBqc3hSZW5kZXJlciBhbiBvcHRpb25hbCByZW5kZXJlciB0byB1c2UuXHJcbiAgICogQHBhcmFtIGFkZGl0aW9uYWxQcm9wcyBvcHRpb25hbCBhZGRpdGlvbmFsIHByb3BzIHRvIHBhc3MgdG8gdGhlIGBSZWFjdENvbnRlbnRgIG9iamVjdCB0aGF0IHdpbGwgcmVuZGVyIHRoZSBjb250ZW50LlxyXG4gICAqL1xyXG4gIHByb3RlY3RlZCBjcmVhdGVSZW5kZXJQcm9wSGFuZGxlcjxUUmVuZGVyUHJvcHMgZXh0ZW5kcyBvYmplY3Q+KFxyXG4gICAgcmVuZGVySW5wdXRWYWx1ZTogSW5wdXRSZW5kZXJlck9wdGlvbnM8VFJlbmRlclByb3BzPixcclxuICAgIG9wdGlvbnM/OiB7XHJcbiAgICAgIGpzeFJlbmRlcmVyPzogSnN4UmVuZGVyRnVuYzxUUmVuZGVyUHJvcHM+O1xyXG4gICAgICBhZGRpdGlvbmFsUHJvcHM/OiBSZWFjdENvbnRlbnRQcm9wcztcclxuICAgIH1cclxuICApOiAocHJvcHM/OiBUUmVuZGVyUHJvcHMsIGRlZmF1bHRSZW5kZXI/OiBKc3hSZW5kZXJGdW5jPFRSZW5kZXJQcm9wcz4pID0+IEpTWC5FbGVtZW50IHwgbnVsbCB7XHJcbiAgICByZXR1cm4gY3JlYXRlUmVuZGVyUHJvcEhhbmRsZXIocmVuZGVySW5wdXRWYWx1ZSwgdGhpcy5fbmdab25lLCBvcHRpb25zKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgX3Bhc3NBdHRyaWJ1dGVzQXNQcm9wcygpIHtcclxuICAgIGNvbnN0IGhvc3RBdHRyaWJ1dGVzID0gQXJyYXkuZnJvbSgodGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQgYXMgSFRNTEVsZW1lbnQpLmF0dHJpYnV0ZXMpO1xyXG5cclxuICAgIGlmICghdGhpcy5yZWFjdE5vZGVSZWYgfHwgIWlzUmVhY3ROb2RlKHRoaXMucmVhY3ROb2RlUmVmLm5hdGl2ZUVsZW1lbnQpKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcigncmVhY3ROb2RlUmVmIG11c3QgaG9sZCBhIHJlZmVyZW5jZSB0byBhIFJlYWN0Tm9kZScpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEVuc3VyZSB0aGVyZSBhcmUgbm8gYmxhY2tsaXN0ZWQgcHJvcHMuIFN1Z2dlc3QgYWx0ZXJuYXRpdmUgYXMgZXJyb3IgaWYgdGhlcmUgaXMgYW55XHJcbiAgICBob3N0QXR0cmlidXRlcy5mb3JFYWNoKGF0dHIgPT4ge1xyXG4gICAgICBjb25zdCBbZm9yYmlkZGVuLCBhbHRlcm5hdGl2ZUF0dHJOYW1lXSA9IHRoaXMuX2lzRm9yYmlkZGVuQXR0cmlidXRlKGF0dHIpO1xyXG4gICAgICBpZiAoZm9yYmlkZGVuKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgICAgYFskeyh0aGlzLmVsZW1lbnRSZWZcclxuICAgICAgICAgICAgLm5hdGl2ZUVsZW1lbnQgYXMgSFRNTEVsZW1lbnQpLnRhZ05hbWUudG9Mb3dlckNhc2UoKX1dIFJlYWN0IHdyYXBwZXIgY29tcG9uZW50cyBjYW5ub3QgaGF2ZSB0aGUgJyR7XHJcbiAgICAgICAgICAgIGF0dHIubmFtZVxyXG4gICAgICAgICAgfScgYXR0cmlidXRlIHNldC4gVXNlIHRoZSBmb2xsb3dpbmcgYWx0ZXJuYXRpdmU6ICR7YWx0ZXJuYXRpdmVBdHRyTmFtZSB8fCAnJ31gXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3Qgd2hpdGVsaXN0ZWRIb3N0QXR0cmlidXRlcyA9IGhvc3RBdHRyaWJ1dGVzLmZpbHRlcihhdHRyID0+ICF0aGlzLl9pc0lnbm9yZWRBdHRyaWJ1dGUoYXR0cikpO1xyXG4gICAgY29uc3QgcHJvcHMgPSB3aGl0ZWxpc3RlZEhvc3RBdHRyaWJ1dGVzLnJlZHVjZShcclxuICAgICAgKGFjYywgYXR0cikgPT4gKHtcclxuICAgICAgICAuLi5hY2MsXHJcbiAgICAgICAgW2F0dHIubmFtZV06IGF0dHIudmFsdWUsXHJcbiAgICAgIH0pLFxyXG4gICAgICB7fVxyXG4gICAgKTtcclxuXHJcbiAgICBjb25zdCBldmVudExpc3RlbmVycyA9IHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmdldEV2ZW50TGlzdGVuZXJzKCk7XHJcbiAgICBjb25zdCBldmVudEhhbmRsZXJzUHJvcHMgPVxyXG4gICAgICBldmVudExpc3RlbmVycyAmJiBPYmplY3Qua2V5cyhldmVudExpc3RlbmVycykubGVuZ3RoXHJcbiAgICAgICAgPyB0b09iamVjdChcclxuICAgICAgICAgICAgT2JqZWN0LnZhbHVlcyhldmVudExpc3RlbmVycykubWFwPFtzdHJpbmcsIFJlYWN0LkV2ZW50SGFuZGxlcjxSZWFjdC5TeW50aGV0aWNFdmVudD5dPigoW2V2ZW50TGlzdGVuZXJdKSA9PiBbXHJcbiAgICAgICAgICAgICAgZXZlbnRMaXN0ZW5lci50eXBlLFxyXG4gICAgICAgICAgICAgIChldjogUmVhY3QuU3ludGhldGljRXZlbnQpID0+IGV2ZW50TGlzdGVuZXIubGlzdGVuZXIoZXYgJiYgZXYubmF0aXZlRXZlbnQpLFxyXG4gICAgICAgICAgICBdKVxyXG4gICAgICAgICAgKVxyXG4gICAgICAgIDoge307XHJcbiAgICB7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5yZWFjdE5vZGVSZWYubmF0aXZlRWxlbWVudC5zZXRQcm9wZXJ0aWVzKHsgLi4ucHJvcHMsIC4uLmV2ZW50SGFuZGxlcnNQcm9wcyB9KTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgX3NldEhvc3REaXNwbGF5KCkge1xyXG4gICAgY29uc3QgbmF0aXZlRWxlbWVudCA9IHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50O1xyXG5cclxuICAgIC8vIFdlIHdhbnQgdG8gd2FpdCB1bnRpbCBjaGlsZCBlbGVtZW50cyBhcmUgcmVuZGVyZWRcclxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICAgIGlmIChuYXRpdmVFbGVtZW50LmZpcnN0RWxlbWVudENoaWxkKSB7XHJcbiAgICAgICAgY29uc3Qgcm9vdENoaWxkRGlzcGxheSA9IGdldENvbXB1dGVkU3R5bGUobmF0aXZlRWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZCkuZGlzcGxheTtcclxuICAgICAgICBuYXRpdmVFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSByb290Q2hpbGREaXNwbGF5O1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgX2lzSWdub3JlZEF0dHJpYnV0ZShhdHRyOiBBdHRyKSB7XHJcbiAgICByZXR1cm4gaWdub3JlZEF0dHJpYnV0ZU1hdGNoZXJzLnNvbWUocmVnRXhwID0+IHJlZ0V4cC50ZXN0KGF0dHIubmFtZSkpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBfaXNGb3JiaWRkZW5BdHRyaWJ1dGUoYXR0cjogQXR0cik6IFtib29sZWFuLCBzdHJpbmcgfCB1bmRlZmluZWRdIHtcclxuICAgIGNvbnN0IHsgbmFtZSwgdmFsdWUgfSA9IGF0dHI7XHJcblxyXG4gICAgaWYgKG5hbWUgPT09ICdrZXknKSByZXR1cm4gW3RydWUsIHVuZGVmaW5lZF07XHJcbiAgICBpZiAobmFtZSA9PT0gJ2NsYXNzJyAmJiB2YWx1ZS5zcGxpdCgnICcpLnNvbWUoY2xhc3NOYW1lID0+ICFuZ0NsYXNzUmVnRXhwLnRlc3QoY2xhc3NOYW1lKSkpXHJcbiAgICAgIHJldHVybiBbdHJ1ZSwgJ2NvbnRlbnRDbGFzcyddO1xyXG4gICAgaWYgKG5hbWUgPT09ICdzdHlsZScpIHtcclxuICAgICAgY29uc3Qgc3R5bGUgPSB0b1N0eWxlKHZhbHVlKTtcclxuICAgICAgLy8gT25seSBhbGxvd2luZyBzdHlsZSBpZiBpdCdzIHNvbWV0aGluZyB0aGF0IGNoYW5nZXMgdGhlIGRpc3BsYXkgLSBzZXR0aW5nIGFueXRoaW5nIGVsc2Ugc2hvdWxkIGJlIGRvbmUgb24gdGhlIGNoaWxkIGNvbXBvbmVudCBkaXJlY3RseSAodmlhIHRoZSBgc3R5bGVzYCBhdHRyaWJ1dGUgaW4gZmFicmljIGZvciBleGFtcGxlKVxyXG4gICAgICBpZiAoT2JqZWN0LmVudHJpZXMoc3R5bGUpLmZpbHRlcigoW2tleSwgdmFsdWVdKSA9PiB2YWx1ZSAmJiBrZXkgIT09ICdkaXNwbGF5JykubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHJldHVybiBbdHJ1ZSwgJ2NvbnRlbnRTdHlsZSddO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIFtmYWxzZSwgdW5kZWZpbmVkXTtcclxuICB9XHJcbn1cclxuIl19