// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
const elementMap = new Map();
const camelCaseSplit = /([a-z0-9])([A-Z])/g;
/**
 * Register an element to be renderer when the renderer sees the tag.
 * @param elementName the tag to be used to get the component type when rendering.
 * @param resolver A resolver to the React component.
 */
export function registerElement(elementName, resolver) {
    if (elementMap.has(elementName)) {
        // Ignore multiple register attempts for the same component.
        // Angular doesn't allow sharing whole NgModule instances (in this case, an @NgModule for React-wrapped components) with lazy-loaded @NgModules (in the app),
        // To keep the API simple, allow multiple calls to `registerElement`.
        // Disadvantage is that you can't replace (React) component implementations at runtime. This sounds far-fetched, but solvable with a `static forRoot()` pattern for every
        // React-wrapper components' @NgModule, ensuring that `registerElement` is only called once.
        return;
    }
    else {
        const entry = { resolver: resolver };
        elementMap.set(elementName, entry);
        elementMap.set(elementName.toLowerCase(), entry);
        elementMap.set(elementName.replace(camelCaseSplit, '$1-$2').toLowerCase(), entry);
    }
}
export function isKnownComponent(elementName) {
    return elementMap.has(elementName) || elementMap.has(elementName.toLowerCase());
}
export function getComponentClass(elementName) {
    const entry = elementMap.get(elementName) || elementMap.get(elementName.toLowerCase());
    if (!entry) {
        // throw new TypeError(`No known component for element ${elementName}.`);
        return elementName;
    }
    try {
        return entry.resolver();
    }
    catch (e) {
        throw new TypeError(`Could not load component for: ${elementName}.${e}`);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVnaXN0cnkuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AYW5ndWxhci1yZWFjdC9jb3JlLyIsInNvdXJjZXMiOlsic3JjL2xpYi9yZW5kZXJlci9yZWdpc3RyeS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSw0REFBNEQ7QUFDNUQsa0NBQWtDO0FBTWxDLE1BQU0sVUFBVSxHQUFHLElBQUksR0FBRyxFQUEyQyxDQUFDO0FBQ3RFLE1BQU0sY0FBYyxHQUFHLG9CQUFvQixDQUFDO0FBRTVDOzs7O0dBSUc7QUFDSCxNQUFNLFVBQVUsZUFBZSxDQUFDLFdBQW1CLEVBQUUsUUFBMkI7SUFDOUUsSUFBSSxVQUFVLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxFQUFFO1FBQy9CLDREQUE0RDtRQUM1RCw2SkFBNko7UUFDN0oscUVBQXFFO1FBQ3JFLHlLQUF5SztRQUN6Syw0RkFBNEY7UUFDNUYsT0FBTztLQUNSO1NBQU07UUFDTCxNQUFNLEtBQUssR0FBRyxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsQ0FBQztRQUNyQyxVQUFVLENBQUMsR0FBRyxDQUFDLFdBQVcsRUFBRSxLQUFLLENBQUMsQ0FBQztRQUNuQyxVQUFVLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxXQUFXLEVBQUUsRUFBRSxLQUFLLENBQUMsQ0FBQztRQUNqRCxVQUFVLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsY0FBYyxFQUFFLE9BQU8sQ0FBQyxDQUFDLFdBQVcsRUFBRSxFQUFFLEtBQUssQ0FBQyxDQUFDO0tBQ25GO0FBQ0gsQ0FBQztBQUVELE1BQU0sVUFBVSxnQkFBZ0IsQ0FBQyxXQUFtQjtJQUNsRCxPQUFPLFVBQVUsQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLElBQUksVUFBVSxDQUFDLEdBQUcsQ0FBQyxXQUFXLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQztBQUNsRixDQUFDO0FBRUQsTUFBTSxVQUFVLGlCQUFpQixDQUFDLFdBQW1CO0lBQ25ELE1BQU0sS0FBSyxHQUFHLFVBQVUsQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLElBQUksVUFBVSxDQUFDLEdBQUcsQ0FBQyxXQUFXLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQztJQUN2RixJQUFJLENBQUMsS0FBSyxFQUFFO1FBQ1YseUVBQXlFO1FBQ3pFLE9BQU8sV0FBVyxDQUFDO0tBQ3BCO0lBRUQsSUFBSTtRQUNGLE9BQU8sS0FBSyxDQUFDLFFBQVEsRUFBRSxDQUFDO0tBQ3pCO0lBQUMsT0FBTyxDQUFDLEVBQUU7UUFDVixNQUFNLElBQUksU0FBUyxDQUFDLGlDQUFpQyxXQUFXLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztLQUMxRTtBQUNILENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG5cclxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5cclxuZXhwb3J0IHR5cGUgQ29tcG9uZW50UmVzb2x2ZXIgPSAoKSA9PiBSZWFjdC5SZWFjdFR5cGU7XHJcblxyXG5jb25zdCBlbGVtZW50TWFwID0gbmV3IE1hcDxzdHJpbmcsIHsgcmVzb2x2ZXI6IENvbXBvbmVudFJlc29sdmVyIH0+KCk7XHJcbmNvbnN0IGNhbWVsQ2FzZVNwbGl0ID0gLyhbYS16MC05XSkoW0EtWl0pL2c7XHJcblxyXG4vKipcclxuICogUmVnaXN0ZXIgYW4gZWxlbWVudCB0byBiZSByZW5kZXJlciB3aGVuIHRoZSByZW5kZXJlciBzZWVzIHRoZSB0YWcuXHJcbiAqIEBwYXJhbSBlbGVtZW50TmFtZSB0aGUgdGFnIHRvIGJlIHVzZWQgdG8gZ2V0IHRoZSBjb21wb25lbnQgdHlwZSB3aGVuIHJlbmRlcmluZy5cclxuICogQHBhcmFtIHJlc29sdmVyIEEgcmVzb2x2ZXIgdG8gdGhlIFJlYWN0IGNvbXBvbmVudC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlckVsZW1lbnQoZWxlbWVudE5hbWU6IHN0cmluZywgcmVzb2x2ZXI6IENvbXBvbmVudFJlc29sdmVyKTogdm9pZCB7XHJcbiAgaWYgKGVsZW1lbnRNYXAuaGFzKGVsZW1lbnROYW1lKSkge1xyXG4gICAgLy8gSWdub3JlIG11bHRpcGxlIHJlZ2lzdGVyIGF0dGVtcHRzIGZvciB0aGUgc2FtZSBjb21wb25lbnQuXHJcbiAgICAvLyBBbmd1bGFyIGRvZXNuJ3QgYWxsb3cgc2hhcmluZyB3aG9sZSBOZ01vZHVsZSBpbnN0YW5jZXMgKGluIHRoaXMgY2FzZSwgYW4gQE5nTW9kdWxlIGZvciBSZWFjdC13cmFwcGVkIGNvbXBvbmVudHMpIHdpdGggbGF6eS1sb2FkZWQgQE5nTW9kdWxlcyAoaW4gdGhlIGFwcCksXHJcbiAgICAvLyBUbyBrZWVwIHRoZSBBUEkgc2ltcGxlLCBhbGxvdyBtdWx0aXBsZSBjYWxscyB0byBgcmVnaXN0ZXJFbGVtZW50YC5cclxuICAgIC8vIERpc2FkdmFudGFnZSBpcyB0aGF0IHlvdSBjYW4ndCByZXBsYWNlIChSZWFjdCkgY29tcG9uZW50IGltcGxlbWVudGF0aW9ucyBhdCBydW50aW1lLiBUaGlzIHNvdW5kcyBmYXItZmV0Y2hlZCwgYnV0IHNvbHZhYmxlIHdpdGggYSBgc3RhdGljIGZvclJvb3QoKWAgcGF0dGVybiBmb3IgZXZlcnlcclxuICAgIC8vIFJlYWN0LXdyYXBwZXIgY29tcG9uZW50cycgQE5nTW9kdWxlLCBlbnN1cmluZyB0aGF0IGByZWdpc3RlckVsZW1lbnRgIGlzIG9ubHkgY2FsbGVkIG9uY2UuXHJcbiAgICByZXR1cm47XHJcbiAgfSBlbHNlIHtcclxuICAgIGNvbnN0IGVudHJ5ID0geyByZXNvbHZlcjogcmVzb2x2ZXIgfTtcclxuICAgIGVsZW1lbnRNYXAuc2V0KGVsZW1lbnROYW1lLCBlbnRyeSk7XHJcbiAgICBlbGVtZW50TWFwLnNldChlbGVtZW50TmFtZS50b0xvd2VyQ2FzZSgpLCBlbnRyeSk7XHJcbiAgICBlbGVtZW50TWFwLnNldChlbGVtZW50TmFtZS5yZXBsYWNlKGNhbWVsQ2FzZVNwbGl0LCAnJDEtJDInKS50b0xvd2VyQ2FzZSgpLCBlbnRyeSk7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaXNLbm93bkNvbXBvbmVudChlbGVtZW50TmFtZTogc3RyaW5nKTogYm9vbGVhbiB7XHJcbiAgcmV0dXJuIGVsZW1lbnRNYXAuaGFzKGVsZW1lbnROYW1lKSB8fCBlbGVtZW50TWFwLmhhcyhlbGVtZW50TmFtZS50b0xvd2VyQ2FzZSgpKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldENvbXBvbmVudENsYXNzKGVsZW1lbnROYW1lOiBzdHJpbmcpOiBSZWFjdC5SZWFjdFR5cGUgfCBzdHJpbmcge1xyXG4gIGNvbnN0IGVudHJ5ID0gZWxlbWVudE1hcC5nZXQoZWxlbWVudE5hbWUpIHx8IGVsZW1lbnRNYXAuZ2V0KGVsZW1lbnROYW1lLnRvTG93ZXJDYXNlKCkpO1xyXG4gIGlmICghZW50cnkpIHtcclxuICAgIC8vIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIGtub3duIGNvbXBvbmVudCBmb3IgZWxlbWVudCAke2VsZW1lbnROYW1lfS5gKTtcclxuICAgIHJldHVybiBlbGVtZW50TmFtZTtcclxuICB9XHJcblxyXG4gIHRyeSB7XHJcbiAgICByZXR1cm4gZW50cnkucmVzb2x2ZXIoKTtcclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBDb3VsZCBub3QgbG9hZCBjb21wb25lbnQgZm9yOiAke2VsZW1lbnROYW1lfS4ke2V9YCk7XHJcbiAgfVxyXG59XHJcbiJdfQ==