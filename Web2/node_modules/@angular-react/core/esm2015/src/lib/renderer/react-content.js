// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
import * as React from 'react';
import * as ReactDOM from 'react-dom';
import * as dom from '../utils/dom/dom-utils';
const DEBUG = false;
export const CHILDREN_TO_APPEND_PROP = 'children-to-append';
/**
 * Creates a new `ReactContent` element.
 * @param children The children to append to the `ReactContent` element.
 * @param additionalProps _Optional_. @see `ReactContentProps`.
 */
export function createReactContentElement(children, additionalProps) {
    return React.createElement(ReactContent, Object.assign({}, additionalProps, { [CHILDREN_TO_APPEND_PROP]: children }));
}
/**
 * Render any `HTMLElement`s as a child of React components.
 * Supports two rendering modes:
 *  1. `legacy` - append `<react-content>` as the root, and nest the `children-to-append` underneath it.
 *  2. `new` (**default**) - append the `children-to-append` to the parent of this component, and hide the `<react-content>` element.
 *     (similar to how `router-outlet` behaves in Angular).
 */
export class ReactContent extends React.PureComponent {
    componentDidMount() {
        const element = ReactDOM.findDOMNode(this);
        if (this.props[CHILDREN_TO_APPEND_PROP]) {
            if (DEBUG) {
                console.warn('ReactContent Component > componentDidMount > childrenToAppend:', this.props[CHILDREN_TO_APPEND_PROP]);
            }
            const hostElement = this.props.legacyRenderMode ? element : element.parentElement;
            // Only add children not already in the DOM
            this.props[CHILDREN_TO_APPEND_PROP].filter(child => !dom.isNodeInDOM(child)).forEach(child => hostElement.appendChild(child));
        }
    }
    render() {
        // TODO: See if we can just render React.Fragment and the children within it, having no extra DOM nodes.
        return React.createElement('react-content', !this.props.legacyRenderMode && { style: { display: 'none' } });
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVhY3QtY29udGVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0Bhbmd1bGFyLXJlYWN0L2NvcmUvIiwic291cmNlcyI6WyJzcmMvbGliL3JlbmRlcmVyL3JlYWN0LWNvbnRlbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsNERBQTREO0FBQzVELGtDQUFrQztBQUVsQyxPQUFPLEtBQUssS0FBSyxNQUFNLE9BQU8sQ0FBQztBQUMvQixPQUFPLEtBQUssUUFBUSxNQUFNLFdBQVcsQ0FBQztBQUN0QyxPQUFPLEtBQUssR0FBRyxNQUFNLHdCQUF3QixDQUFDO0FBRTlDLE1BQU0sS0FBSyxHQUFHLEtBQUssQ0FBQztBQUNwQixNQUFNLENBQUMsTUFBTSx1QkFBdUIsR0FBRyxvQkFBb0IsQ0FBQztBQWdCNUQ7Ozs7R0FJRztBQUNILE1BQU0sVUFBVSx5QkFBeUIsQ0FBQyxRQUFvQyxFQUFFLGVBQW1DO0lBQ2pILE9BQU8sS0FBSyxDQUFDLGFBQWEsQ0FBQyxZQUFZLG9CQUNsQyxlQUFlLElBQ2xCLENBQUMsdUJBQXVCLENBQUMsRUFBRSxRQUFRLElBQ25DLENBQUM7QUFDTCxDQUFDO0FBU0Q7Ozs7OztHQU1HO0FBQ0gsTUFBTSxPQUFPLFlBQWEsU0FBUSxLQUFLLENBQUMsYUFBd0M7SUFDOUUsaUJBQWlCO1FBQ2YsTUFBTSxPQUFPLEdBQUcsUUFBUSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUMzQyxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsdUJBQXVCLENBQUMsRUFBRTtZQUN2QyxJQUFJLEtBQUssRUFBRTtnQkFDVCxPQUFPLENBQUMsSUFBSSxDQUNWLGdFQUFnRSxFQUNoRSxJQUFJLENBQUMsS0FBSyxDQUFDLHVCQUF1QixDQUFDLENBQ3BDLENBQUM7YUFDSDtZQUVELE1BQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQztZQUVsRiwyQ0FBMkM7WUFDM0MsSUFBSSxDQUFDLEtBQUssQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUMzRixXQUFXLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUMvQixDQUFDO1NBQ0g7SUFDSCxDQUFDO0lBRUQsTUFBTTtRQUNKLHdHQUF3RztRQUN4RyxPQUFPLEtBQUssQ0FBQyxhQUFhLENBQUMsZUFBZSxFQUFFLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxnQkFBZ0IsSUFBSSxFQUFFLEtBQUssRUFBRSxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUUsRUFBRSxDQUFDLENBQUM7SUFDOUcsQ0FBQztDQUNGIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuXHJcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0ICogYXMgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcclxuaW1wb3J0ICogYXMgZG9tIGZyb20gJy4uL3V0aWxzL2RvbS9kb20tdXRpbHMnO1xyXG5cclxuY29uc3QgREVCVUcgPSBmYWxzZTtcclxuZXhwb3J0IGNvbnN0IENISUxEUkVOX1RPX0FQUEVORF9QUk9QID0gJ2NoaWxkcmVuLXRvLWFwcGVuZCc7XHJcblxyXG4vKipcclxuICogUHJvcHMgdGhhdCBjYW4gYmUgcGFzc2VkIHRvIGBSZWFjdENvbnRlbnRgIGZyb20gdXNlcnMuXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIFJlYWN0Q29udGVudFByb3BzIHtcclxuICAvKipcclxuICAgKiBVc2UgdGhlIGxlZ2FjeSByZW5kZXJpbmcgbW9kZS5cclxuICAgKlxyXG4gICAqIFVzZXMgYSBzaW1pbGFyIGFwcHJvYWNoIHRvIGByb3V0ZXItb3V0bGV0YCwgd2hlcmUgdGhlIGNoaWxkIGVsZW1lbnRzIGFyZSBhZGRlZCB0byB0aGUgcGFyZW50LCBpbnN0ZWFkIG9mIHRoaXMgbm9kZSwgYW5kIHRoaXMgaXMgaGlkZGVuLlxyXG4gICAqXHJcbiAgICogQGRlZmF1bHQgZmFsc2VcclxuICAgKi9cclxuICBsZWdhY3lSZW5kZXJNb2RlPzogYm9vbGVhbjtcclxufVxyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgYFJlYWN0Q29udGVudGAgZWxlbWVudC5cclxuICogQHBhcmFtIGNoaWxkcmVuIFRoZSBjaGlsZHJlbiB0byBhcHBlbmQgdG8gdGhlIGBSZWFjdENvbnRlbnRgIGVsZW1lbnQuXHJcbiAqIEBwYXJhbSBhZGRpdGlvbmFsUHJvcHMgX09wdGlvbmFsXy4gQHNlZSBgUmVhY3RDb250ZW50UHJvcHNgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVJlYWN0Q29udGVudEVsZW1lbnQoY2hpbGRyZW46IFJlYWRvbmx5QXJyYXk8SFRNTEVsZW1lbnQ+LCBhZGRpdGlvbmFsUHJvcHM/OiBSZWFjdENvbnRlbnRQcm9wcykge1xyXG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0Q29udGVudCwge1xyXG4gICAgLi4uYWRkaXRpb25hbFByb3BzLFxyXG4gICAgW0NISUxEUkVOX1RPX0FQUEVORF9QUk9QXTogY2hpbGRyZW4sXHJcbiAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmludGVyZmFjZSBJbnRlcm5hbFJlYWN0Q29udGVudFByb3BzIGV4dGVuZHMgUmVhY3RDb250ZW50UHJvcHMge1xyXG4gIHJlYWRvbmx5IFtDSElMRFJFTl9UT19BUFBFTkRfUFJPUF06IFJlYWRvbmx5QXJyYXk8SFRNTEVsZW1lbnQ+O1xyXG59XHJcblxyXG4vKipcclxuICogUmVuZGVyIGFueSBgSFRNTEVsZW1lbnRgcyBhcyBhIGNoaWxkIG9mIFJlYWN0IGNvbXBvbmVudHMuXHJcbiAqIFN1cHBvcnRzIHR3byByZW5kZXJpbmcgbW9kZXM6XHJcbiAqICAxLiBgbGVnYWN5YCAtIGFwcGVuZCBgPHJlYWN0LWNvbnRlbnQ+YCBhcyB0aGUgcm9vdCwgYW5kIG5lc3QgdGhlIGBjaGlsZHJlbi10by1hcHBlbmRgIHVuZGVybmVhdGggaXQuXHJcbiAqICAyLiBgbmV3YCAoKipkZWZhdWx0KiopIC0gYXBwZW5kIHRoZSBgY2hpbGRyZW4tdG8tYXBwZW5kYCB0byB0aGUgcGFyZW50IG9mIHRoaXMgY29tcG9uZW50LCBhbmQgaGlkZSB0aGUgYDxyZWFjdC1jb250ZW50PmAgZWxlbWVudC5cclxuICogICAgIChzaW1pbGFyIHRvIGhvdyBgcm91dGVyLW91dGxldGAgYmVoYXZlcyBpbiBBbmd1bGFyKS5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBSZWFjdENvbnRlbnQgZXh0ZW5kcyBSZWFjdC5QdXJlQ29tcG9uZW50PEludGVybmFsUmVhY3RDb250ZW50UHJvcHM+IHtcclxuICBjb21wb25lbnREaWRNb3VudCgpIHtcclxuICAgIGNvbnN0IGVsZW1lbnQgPSBSZWFjdERPTS5maW5kRE9NTm9kZSh0aGlzKTtcclxuICAgIGlmICh0aGlzLnByb3BzW0NISUxEUkVOX1RPX0FQUEVORF9QUk9QXSkge1xyXG4gICAgICBpZiAoREVCVUcpIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oXHJcbiAgICAgICAgICAnUmVhY3RDb250ZW50IENvbXBvbmVudCA+IGNvbXBvbmVudERpZE1vdW50ID4gY2hpbGRyZW5Ub0FwcGVuZDonLFxyXG4gICAgICAgICAgdGhpcy5wcm9wc1tDSElMRFJFTl9UT19BUFBFTkRfUFJPUF1cclxuICAgICAgICApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBob3N0RWxlbWVudCA9IHRoaXMucHJvcHMubGVnYWN5UmVuZGVyTW9kZSA/IGVsZW1lbnQgOiBlbGVtZW50LnBhcmVudEVsZW1lbnQ7XHJcblxyXG4gICAgICAvLyBPbmx5IGFkZCBjaGlsZHJlbiBub3QgYWxyZWFkeSBpbiB0aGUgRE9NXHJcbiAgICAgIHRoaXMucHJvcHNbQ0hJTERSRU5fVE9fQVBQRU5EX1BST1BdLmZpbHRlcihjaGlsZCA9PiAhZG9tLmlzTm9kZUluRE9NKGNoaWxkKSkuZm9yRWFjaChjaGlsZCA9PlxyXG4gICAgICAgIGhvc3RFbGVtZW50LmFwcGVuZENoaWxkKGNoaWxkKVxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmVuZGVyKCkge1xyXG4gICAgLy8gVE9ETzogU2VlIGlmIHdlIGNhbiBqdXN0IHJlbmRlciBSZWFjdC5GcmFnbWVudCBhbmQgdGhlIGNoaWxkcmVuIHdpdGhpbiBpdCwgaGF2aW5nIG5vIGV4dHJhIERPTSBub2Rlcy5cclxuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KCdyZWFjdC1jb250ZW50JywgIXRoaXMucHJvcHMubGVnYWN5UmVuZGVyTW9kZSAmJiB7IHN0eWxlOiB7IGRpc3BsYXk6ICdub25lJyB9IH0pO1xyXG4gIH1cclxufVxyXG4iXX0=