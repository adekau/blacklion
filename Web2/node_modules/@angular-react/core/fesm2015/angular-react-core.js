import { __rest, __decorate, __metadata } from 'tslib';
import { Injectable, RendererStyleFlags2, NgModule, TemplateRef, ComponentRef, Input } from '@angular/core';
import { ɵDomRendererFactory2, EventManager, ɵDomSharedStylesHost, BrowserModule } from '@angular/platform-browser';
import { createElement, PureComponent, Children, Fragment, Component } from 'react';
import { findDOMNode, unmountComponentAtNode, render } from 'react-dom';
import classnames from 'classnames';
import toStyle from 'css-to-style';
import stylenames from 'stylenames';
import { throttleTime } from 'rxjs/operators';

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
const passPropsSymbol = Symbol('passProps');
function passPropImpl(target, propertyKey, targetKey) {
    if (!target[passPropsSymbol]) {
        target[passPropsSymbol] = [];
    }
    target[passPropsSymbol].push({
        sourceKey: propertyKey,
        targetKey: targetKey,
    });
}
const passPropRename = propName => (target, propertyKey) => passPropImpl(target, propertyKey, propName);
const passPropDirect = (target, propertyKey) => passPropImpl(target, propertyKey, propertyKey);
function passProp(...args) {
    if (args.length === 0) {
        return passPropDirect;
    }
    if (args.length === 1) {
        return passPropRename(args[0]);
    }
    throw new Error('[passProp] Only 0 or 1 arguments accepted.');
}
function getPassProps(obj) {
    return obj[passPropsSymbol];
}

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
/**
 * Remove all undefined properties from obj.
 *
 * Does **not** modify the original object.
 * @returns A clone of `obj`, with all `undefined` properties removed
 */
const removeUndefinedProperties = (obj) => {
    return Object.entries(obj).reduce((acc, [key, value]) => {
        if (value === undefined)
            return acc;
        return Object.assign(acc, { [key]: value });
    }, {});
};

/**
 * Checks if a node is in the DOM.
 *
 * @param node The node to check
 * @returns whether the node is in the DOM
 */
const isNodeInDOM = (node) => node.isConnected || document.body.contains(node);

// Copyright (c) Microsoft Corporation. All rights reserved.
const CHILDREN_TO_APPEND_PROP = 'children-to-append';
/**
 * Creates a new `ReactContent` element.
 * @param children The children to append to the `ReactContent` element.
 * @param additionalProps _Optional_. @see `ReactContentProps`.
 */
function createReactContentElement(children, additionalProps) {
    return createElement(ReactContent, Object.assign({}, additionalProps, { [CHILDREN_TO_APPEND_PROP]: children }));
}
/**
 * Render any `HTMLElement`s as a child of React components.
 * Supports two rendering modes:
 *  1. `legacy` - append `<react-content>` as the root, and nest the `children-to-append` underneath it.
 *  2. `new` (**default**) - append the `children-to-append` to the parent of this component, and hide the `<react-content>` element.
 *     (similar to how `router-outlet` behaves in Angular).
 */
class ReactContent extends PureComponent {
    componentDidMount() {
        const element = findDOMNode(this);
        if (this.props[CHILDREN_TO_APPEND_PROP]) {
            const hostElement = this.props.legacyRenderMode ? element : element.parentElement;
            // Only add children not already in the DOM
            this.props[CHILDREN_TO_APPEND_PROP].filter(child => !isNodeInDOM(child)).forEach(child => hostElement.appendChild(child));
        }
    }
    render() {
        // TODO: See if we can just render React.Fragment and the children within it, having no extra DOM nodes.
        return createElement('react-content', !this.props.legacyRenderMode && { style: { display: 'none' } });
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * A React component that can render a component and its children as other component types.
 */
class Disguise extends PureComponent {
    render() {
        const _a = this.props, { disguiseRootAs, disguiseChildrenAs, children, ngChildComponents } = _a, rest = __rest(_a, ["disguiseRootAs", "disguiseChildrenAs", "children", "ngChildComponents"]);
        const Root = disguiseRootAs || Fragment;
        const renderedChildren = ngChildComponents
            ? this._isReactContentOnlyChild()
                ? this._renderReactContentChildren()
                : this._renderChildrenNaive()
            : children;
        return createElement(Root, rest || null, renderedChildren);
    }
    _isReactContentOnlyChild() {
        const { children } = this.props;
        if (Children.count(children) === 1) {
            const [onlyChild] = Children.toArray(children);
            if (typeof onlyChild === 'object' && onlyChild.type === ReactContent) {
                return true;
            }
        }
        return false;
    }
    _renderReactContentChildren() {
        const { ngChildComponents, disguiseChildrenAs } = this.props;
        const renderedChildren = ngChildComponents.map((child, index) => {
            const propsToPass = removeUndefinedProperties(getPassProps(child).reduce((acc, passProp) => Object.assign(acc, { [passProp.targetKey]: child[passProp.sourceKey] }), {}));
            return createElement(disguiseChildrenAs, Object.assign({}, propsToPass, { key: index, ref: childReactElement => {
                    // ref callback is called with null when the component unmounts from the DOM, we don't need to handle it.
                    if (!childReactElement) {
                        return;
                    }
                    findDOMNode(childReactElement).appendChild(child.elementRef.nativeElement);
                } }));
        });
        return renderedChildren;
    }
    _renderChildrenNaive() {
        const { children, disguiseChildrenAs } = this.props;
        const renderedChildren = Children.map(children, child => {
            if (!disguiseChildrenAs || typeof child !== 'object') {
                return child;
            }
            const ChildRoot = child.type || disguiseChildrenAs;
            return createElement(ChildRoot, Object.assign({}, child.props, { key: child.key }), child);
        });
        return renderedChildren;
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
const elementMap = new Map();
const camelCaseSplit = /([a-z0-9])([A-Z])/g;
/**
 * Register an element to be renderer when the renderer sees the tag.
 * @param elementName the tag to be used to get the component type when rendering.
 * @param resolver A resolver to the React component.
 */
function registerElement(elementName, resolver) {
    if (elementMap.has(elementName)) {
        // Ignore multiple register attempts for the same component.
        // Angular doesn't allow sharing whole NgModule instances (in this case, an @NgModule for React-wrapped components) with lazy-loaded @NgModules (in the app),
        // To keep the API simple, allow multiple calls to `registerElement`.
        // Disadvantage is that you can't replace (React) component implementations at runtime. This sounds far-fetched, but solvable with a `static forRoot()` pattern for every
        // React-wrapper components' @NgModule, ensuring that `registerElement` is only called once.
        return;
    }
    else {
        const entry = { resolver: resolver };
        elementMap.set(elementName, entry);
        elementMap.set(elementName.toLowerCase(), entry);
        elementMap.set(elementName.replace(camelCaseSplit, '$1-$2').toLowerCase(), entry);
    }
}
function getComponentClass(elementName) {
    const entry = elementMap.get(elementName) || elementMap.get(elementName.toLowerCase());
    if (!entry) {
        // throw new TypeError(`No known component for element ${elementName}.`);
        return elementName;
    }
    try {
        return entry.resolver();
    }
    catch (e) {
        throw new TypeError(`Could not load component for: ${elementName}.${e}`);
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
function isReactNode(node) {
    return node.setRenderPendingCallback !== undefined;
}
/**
 * Logical representation of everything needed to render a React element in the
 * DOM, with the needed methods to do so.
 */
class ReactNode {
    constructor(type) {
        this.type = type;
        // Access to these properties are restricted through setters and functions
        // so that the dirty "render pending" state of this object can be properly
        // tracked and all nodes with "render pending" can be flushed at the end
        // of a render operation.
        this._props = {};
        this._children = [];
        this._childrenToAppend = [];
        this._isDestroyPending = false;
        this._isRenderPending = true;
        this.setRenderPendingCallback = () => null;
        this.setRenderPending();
        this._tryResolveTypeIsReactElementClass();
    }
    get domElement() {
        return this._renderedDomElement;
    }
    set parent(parent) {
        this._parent = parent;
        this.setRenderPending();
    }
    get parent() {
        return this._parent;
    }
    get shouldRender() {
        return !this._isNotRenderable;
    }
    get destroyPending() {
        return this._isDestroyPending;
    }
    /**
     * Track all pending render operations internally and set flag on
     * renderer factory so that a flush operation can be scheduled for
     * the "end" of render.
     */
    setRenderPending() {
        this.setRenderPendingCallback();
        this._isRenderPending = true;
    }
    /**
     * Marks the node to be removed from the DOM in the next render cycle.
     */
    destroyNode() {
        this.setRenderPending();
        this._isDestroyPending = true;
    }
    /**
     * Sets an attribute on the node.
     * @note the value can only be a `string`. See `setProperty` for other use-cases.
     * @see `Renderer2#setAttribute`.
     *
     * @param name The attribute name.
     * @param value The new value.
     */
    setAttribute(name, value) {
        this.setAttributes({ [name]: value });
    }
    /**
     * Set attributes on this node.
     * Note that values can only be of type `string`. See `setProperties` for other use-cases.
     * @see `Renderer2#setAttribute`.
     *
     * @param attributes the attributes to set.
     */
    setAttributes(attributes) {
        this.setProperties(attributes);
    }
    /**
     * Sets a prop in the underlying React element.
     * @see `Renderer2#setProperty`.
     *
     * @param name The property name.
     * @param value The new value.
     */
    setProperty(name, value) {
        this.setProperties({ [name]: value });
    }
    /**
     * Like `setProperty` but for multiple props at once.
     *
     * @param properties An object with the props.
     */
    setProperties(properties) {
        this.setRenderPending();
        Object.assign(this._props, removeUndefinedProperties(properties));
    }
    /**
     * Remove a prop or an attribute from the underlying React element.
     * @see `Renderer2#removeAttribute`.
     *
     * @param name The property name.
     * @param childName _Optional_ A property of `name` to remove instead.
     * @returns the deleted property
     */
    removeProperty(name, childName) {
        this.setRenderPending();
        if (childName) {
            return delete this._props[name][childName];
        }
        return delete this._props[name];
    }
    /**
     * Add a direct child of this node.
     * @see `Renderer2#addChild`.
     *
     * @param node The node to add.
     */
    addChild(node) {
        this.setRenderPending();
        this._children.push(node);
    }
    /**
     * Remove a direct child of this node.
     * @see `Renderer2#removeChild`.
     *
     * @param node The node to remove.
     */
    removeChild(node) {
        this.setRenderPending();
        this._children = this._children.filter(child => child !== node);
    }
    /**
     * Cast the node to a comment node.
     * @see `Renderer2#createComment`.
     *
     * @param value the text in the comment to render.
     * @returns itself.
     */
    asComment(value) {
        this.setRenderPending();
        this.type = undefined;
        this._comment = value;
        return this;
    }
    /**
     * Cast the node to a text node.
     * @see `Renderer2#createText`.
     *
     * @param value the text to render.
     * @returns itself.
     */
    asText(value) {
        this.setRenderPending();
        this.type = undefined;
        this._text = value;
        // Skip appending and rendering of empty text nodes. This may cause a bug
        // if a single space is desired...
        if (!value || !value.trim()) {
            this._isNotRenderable = true;
        }
        return this;
    }
    /**
     * Render the node to the DOM, or unmount it, as necessary.
     *
     * @returns itself.
     */
    render() {
        // Only complete render operations for ReactNodes that are parented by HTMLElements.
        // Those that are parented by other ReactNodes will be rendered recursively by their
        // parent.
        if (!isReactNode(this._parent)) {
            if (this._isDestroyPending && this._parent) {
                unmountComponentAtNode(this._parent);
                return this;
            }
            if (this._isRenderPending) {
                // It is expected that the element will be recreated and re-rendered with each attribute change.
                // See: https://reactjs.org/docs/rendering-elements.html
                render(this._renderRecursive(), this._parent);
                this._isRenderPending = false;
            }
        }
        return this;
    }
    /**
     * Appends a child.
     *
     * @see `Renderer2#appendChild`.
     * @note This is called by Angular core when projected content is being added.
     *
     * @param projectedContent the content to project.
     */
    appendChild(projectedContent) {
        this._childrenToAppend.push(projectedContent);
    }
    /**
     * @note for easier debugging.
     */
    toString() {
        if (this._typeName) {
            return `[${this._typeName} ReactNode]`;
        }
        if (this._text) {
            return '[text ReactNode]';
        }
        if (this._comment) {
            return '[comment ReactNode]';
        }
        return '[undefined ReactNode]';
    }
    _renderRecursive(key) {
        const children = this._children
            ? this._children.map((child, index) => child._renderRecursive(index.toString()))
            : [];
        if (this._text) {
            return this._text;
        }
        this._props[CHILDREN_TO_APPEND_PROP] = this._childrenToAppend;
        if (key) {
            this._props['key'] = key;
        }
        // Just having some props on a React element can cause it to
        // behave undesirably, and since the templates are hard-coded to pass
        // all Inputs all the time, they pass `undefined` values too.
        // This ensures these are removed.
        // Additionally, there are some things that Angular templating forbids,
        // and stops at-compile time (with errors), such as `Input`s being prefixed with `on`.
        // Since React does not have the notion of `Output`s as Angular (they are just props of type function, essentially callbacks).
        // To work around this, we, by convention, prefix any PascalCased prop with `on` here, after the template has already been compiled.
        const clearedProps = this._transformProps(removeUndefinedProperties(this._props));
        return createElement(this.type, clearedProps, children.length > 0 ? children : undefined);
    }
    _transformProps(props) {
        return Object.entries(props).reduce((acc, [key, value]) => {
            const [newKey, newValue] = typeof key !== 'string' ? [key, value] : this._transformProp(key, value);
            return Object.assign(acc, { [newKey]: newValue });
        }, {});
    }
    _transformProp(name, value) {
        // prop name is camelCased already
        const firstLetter = name[0];
        if (firstLetter === firstLetter.toLowerCase()) {
            return [name, value];
        }
        // prop name is PascalCased & is a function - assuming render prop or callback prop that has return value
        // NOTE: Angular doesn't allow passing @Inputs that are prefixed with "on". This is useful for render props and properties representing the "on" state (for example, Toggle).
        // As a convention, any @Input that starts with a capital letter is prefixed with "on" when passed as a prop to the underlying React component.
        return [`on${name}`, value];
    }
    _tryResolveTypeIsReactElementClass() {
        if (this._typeIsReactElementClass === undefined) {
            // Comments and text have no type.
            if (!this.type) {
                return;
            }
            // Store the name of the type for the toString message (debugging).
            this._typeName = this.type;
            // Attempt to resolve the type as a React Element class name/type.
            // Since Angular templates are just strings, we can't include types in them.
            // Therefore, we use the component registry to resolve the type of a component from a string.
            if (typeof this.type === 'string') {
                this.type = getComponentClass(this.type);
            }
            // If type is still a string, then no React Element matches this string.
            this._typeIsReactElementClass = typeof this.type !== 'string';
        }
    }
}

/**
 * Monkey-patches `Element`'s `addEventListener` & `removeEventListener` and adds `getEventListeners`.
 * This later allows the renderer to emit any event handlers attached to React-wrapped components as Angular Outputs:
 * ```html
 * <my-component (arbitraryEvent)="onEventHandler($event)"></my-component>
 * ```
 *
 * @note Taken and modified from https://github.com/colxi/getEventListeners to be compiled into ES5, allowing running in older browsers
 **/
Element.prototype['_addEventListener'] = Element.prototype.addEventListener;
Element.prototype['_removeEventListener'] = Element.prototype.removeEventListener;
Element.prototype.addEventListener = function (type, listener, options) {
    if (options === undefined)
        options = false;
    // declare listener
    this._addEventListener(type, listener, options);
    if (!this.eventListenerList)
        this.eventListenerList = {};
    if (!this.eventListenerList[type])
        this.eventListenerList[type] = [];
    // add listener to  event tracking list
    this.eventListenerList[type].push({
        type: type,
        listener: listener,
        useCapture: options,
    });
};
Element.prototype.removeEventListener = function (type, listener, options) {
    if (options === undefined)
        options = false;
    // remove listener
    this._removeEventListener(type, listener, options);
    if (!this.eventListenerList)
        this.eventListenerList = {};
    if (!this.eventListenerList[type])
        this.eventListenerList[type] = [];
    // Find the event in the list, If a listener is registered twice, one
    // with capture and one without, remove each one separately. Removal of
    // a capturing listener does not affect a non-capturing version of the
    // same listener, and vice versa.
    for (let i = 0; i < this.eventListenerList[type].length; i++) {
        if (this.eventListenerList[type][i].listener === listener &&
            this.eventListenerList[type][i].useCapture === options) {
            this.eventListenerList[type].splice(i, 1);
            break;
        }
    }
    // if no more events of the removed event type are left,remove the group
    if (this.eventListenerList[type].length == 0)
        delete this.eventListenerList[type];
};
Element.prototype.getEventListeners = function (type) {
    if (!this.eventListenerList)
        this.eventListenerList = {};
    // return requested listeners type or all them
    if (type === undefined)
        return this.eventListenerList;
    return this.eventListenerList[type];
};
/*
    Element.prototype.clearEventListeners = function(a){
        if(!this.eventListenerList)
            this.eventListenerList = {};
        if(a==undefined){
            for(var x in (this.getEventListeners())) this.clearEventListeners(x);
            return;
        }
        var el = this.getEventListeners(a);
        if(el==undefined)
            return;
        for(var i = el.length - 1; i >= 0; --i) {
            var ev = el[i];
            this.removeEventListener(a, ev.listener, ev.useCapture);
        }
    };
    */

// Copyright (c) Microsoft Corporation. All rights reserved.
let AngularReactRendererFactory = class AngularReactRendererFactory extends ɵDomRendererFactory2 {
    constructor(eventManager, sharedStylesHost) {
        super(eventManager, sharedStylesHost, 'app-id');
        // Collection of ReactNodes that can be evaluated and flushed at the
        // end of Render.  This is necessary as the flow of element creation
        // and update goes from "create" > "insert" > "update" property/attribute.
        // React elements cannot be "inserted" and later have their props
        // updated, so the "insert", or React.Render, can only be done once the
        // element has been fully defined.  Only the topmost [root] nodes are added here.
        this.reactRootNodes = new Set();
        // This flag can only be set to true from outside.  It can only be reset
        // to false from inside.  This value is reset on "end" when the pending
        // renders are flushed.
        this.setRenderPendingCallback = () => {
            this.isRenderPending = true;
        };
        // tslint:disable-next-line: no-use-before-declare
        this.defaultReactRenderer = new ReactRenderer(this);
    }
    createRenderer(element, type) {
        if (type && type.styles.length && type.styles[0] === 'react-renderer') {
            return this.defaultReactRenderer;
        }
        return super.createRenderer(element, type);
    }
    begin() { }
    end() {
        // Flush any pending React element render updates.  This cannot be done
        // earlier (as is done for DOM elements) because React element props
        // are ReadOnly.
        if (this.isRenderPending) {
            // Remove root nodes that are pending destroy after render.
            this.reactRootNodes = new Set(Array.from(this.reactRootNodes).filter(node => !node.render().destroyPending));
            this.isRenderPending = false;
        }
    }
};
AngularReactRendererFactory = __decorate([
    Injectable(),
    __metadata("design:paramtypes", [EventManager, ɵDomSharedStylesHost])
], AngularReactRendererFactory);
const isReactRendererData = (data) => data && typeof data.addRootNode === 'function';
class ReactRenderer {
    constructor(rootRenderer) {
        this.rootRenderer = rootRenderer;
        this.data = {
            addRootNode: (node) => {
                this.rootRenderer.reactRootNodes.add(node);
            },
        };
        // These two elements are essential for the whole experience to be smooth for the user - register them from the get-go.
        registerElement('ReactContent', () => ReactContent);
        registerElement('Disguise', () => Disguise);
    }
    destroy() { }
    destroyNode(node) {
        node.destroyNode();
    }
    createElement(name, namespace) {
        return new ReactNode(name);
    }
    createComment(value) {
        return new ReactNode().asComment(value);
    }
    createText(value) {
        return new ReactNode().asText(value);
    }
    appendChild(parent, node) {
        // Only append a child if there is a child to append.
        if (!node) {
            return;
        }
        // Don't append empty text nodes.
        if (!node.shouldRender) {
            return;
        }
        // Provide a parent element reference to the ReactNode.  This will be used later
        // once the ReactNode is fully defined and it is subsequently rendered.
        if (!isReactNode(parent)) {
            node.setRenderPendingCallback = this.rootRenderer.setRenderPendingCallback;
            this.rootRenderer.reactRootNodes.add(node);
            node.parent = parent;
            return;
        }
        node.setRenderPendingCallback = () => parent.setRenderPending();
        parent.addChild(node);
        node.parent = parent;
    }
    insertBefore(parent, node, refChild) {
        // Only insert a child if there is a parent.
        if (!parent) {
            return;
        }
        const target = document.createElement('div');
        parent.insertBefore(target, refChild);
        node.parent = target;
        node.setRenderPendingCallback = this.rootRenderer.setRenderPendingCallback;
    }
    removeChild(parent, node) {
        // Only insert a child if there is a parent.
        if (!parent) {
            return;
        }
        // Remove a parent element reference from the ReactNode.  This will be later
        // result in the ReactNode unloading itself.
        if (!isReactNode(parent)) {
            node.parent = null;
            return;
        }
        parent.removeChild(node);
    }
    selectRootElement(selectorOrNode) {
    }
    parentNode(node) {
    }
    nextSibling(node) {
    }
    setAttribute(node, name, value, namespace) {
        node.setProperty(name, value);
    }
    removeAttribute(node, name, namespace) {
        node.removeProperty(name);
    }
    addClass(node, name) {
        // Update the virtual node.
        // TODO: This may only support a single class name, but might work if property name is a single
        //       comma-delimited list of classes...
        node.setProperty('className', name);
    }
    removeClass(node, name) {
        // Update the virtual node.
        // TODO: This may not work correctly to remove a single name from a comma-delimited list.
        node.removeProperty('className');
    }
    setStyle(node, style, value, flags) {
        // if (DEBUG) { console.log('Renderer > setStyle > node: ', node.toString(), 'style:', style, 'value:', value, 'flags:', flags); }
        if (flags & RendererStyleFlags2.DashCase) {
            node.setProperty('style', { style: value + !!(flags & RendererStyleFlags2.Important) ? ' !important' : '' });
        }
        else {
            node.setProperty('style', { style: value });
        }
    }
    removeStyle(node, style, flags) {
        node.removeProperty('style', style);
    }
    setProperty(node, name, value) {
        node.setProperty(name, value);
    }
    setValue(node, value) {
        node.setProperty('value', value);
    }
    listen(target, event, callback) {
        target.setProperty(event, callback);
        // TODO: NEEDS WORK: Implement prevent default callback behavior.
        // return <() => void>this.eventManager.addEventListener(
        //            target, event, decoratePreventDefault(callback)) as() => void;
        // tslint:disable-next-line:no-unused-expression
        return () => null;
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
let AngularReactBrowserModule = class AngularReactBrowserModule {
};
AngularReactBrowserModule = __decorate([
    NgModule({
        imports: [BrowserModule],
        exports: [BrowserModule],
        providers: [{ provide: ɵDomRendererFactory2, useClass: AngularReactRendererFactory }],
    })
], AngularReactBrowserModule);

/**
 * Transforms an array of [key, value] tuples to an object
 */
function toObject(pairs) {
    return pairs.reduce((acc, [key, value]) => Object.assign(acc, {
        [key]: value,
    }), {});
}

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
/**
 * Delays the execution of a function to be after the next render.
 *
 * @param callback The function to execute
 */
const afterRenderFinished = (callback) => {
    setTimeout(callback, 0);
};

// Copyright (c) Microsoft Corporation. All rights reserved.
const TEMPLATE_DETECT_CHANGES_THROTTLE_MS = 250;
/**
 * Creates a new `ReactTemplate` element.
 * @param templateRef The template to render.
 * @param context The context to inject the template.
 * @param ngZone A zone used for tracking changes in the template.
 * @param additionalProps _Optional_. @see `ReactTemplateProps`.
 */
function createReactTemplateElement(templateRef, context, ngZone, additionalProps) {
    return createElement(ReactTemplate, Object.assign({ ngZone, templateRef, context }, additionalProps));
}
/**
 * Render an `ng-template` as a child of a React component.
 * Supports two rendering modes:
 *  1. `legacy` - append `<react-content>` as the root, and nest the `children-to-append` underneath it.
 *  2. `new` (**default**) - append the `children-to-append` to the parent of this component, and hide the `<react-content>` element.
 *     (similar to how `router-outlet` behaves in Angular).
 */
class ReactTemplate extends Component {
    componentDidUpdate() {
        // Context has changes, trigger change detection after pushing the new context in
        if (this.props.context != null && this._embeddedViewRef.context != null) {
            Object.assign(this._embeddedViewRef.context, this.props.context);
        }
        this._embeddedViewRef.detectChanges();
    }
    componentDidMount() {
        const { context, ngZone, templateRef } = this.props;
        this._embeddedViewRef = templateRef.createEmbeddedView(context);
        const element = findDOMNode(this);
        const hostElement = this.props.legacyRenderMode ? element : element.parentElement;
        this._embeddedViewRef.rootNodes.forEach(child => hostElement.appendChild(child));
        // Detect the first cycle's changes, and then subscribe for subsequent ones.
        this._embeddedViewRef.detectChanges();
        // Throttling the detect changes to an empirically selected value so we don't overload too much work.
        // TODO: This needs some better solution to listen to changes to the binding sources of the template.
        this._ngZoneSubscription = ngZone.onStable
            .pipe(throttleTime(TEMPLATE_DETECT_CHANGES_THROTTLE_MS, undefined, { leading: true, trailing: true }))
            .subscribe(() => {
            this._embeddedViewRef.detectChanges();
        });
    }
    componentWillUnmount() {
        this._ngZoneSubscription.unsubscribe();
        if (this._embeddedViewRef) {
            this._embeddedViewRef.destroy();
        }
    }
    render() {
        // TODO: See if we can just render React.Fragment and the children within it, having no extra DOM nodes.
        return createElement('react-template', !this.props.legacyRenderMode && { style: { display: 'none' } });
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
function isRenderPropContext(x) {
    if (typeof x !== 'object') {
        return false;
    }
    const maybeRenderPropContext = x;
    return maybeRenderPropContext.render && typeof maybeRenderPropContext.render === 'function';
}
function renderReactContent(rootNodes, additionalProps) {
    return createReactContentElement(rootNodes, additionalProps);
}
/**
 * Wrap a `TemplateRef` with a `JSX.Element`.
 *
 * @param templateRef The template to wrap
 * @param ngZone A zone used for tracking & triggering updates to the template
 * @param additionalProps optional additional props to pass to the `ReactContent` object that will render the content.
 */
function createTemplateRenderer(templateRef, ngZone, additionalProps) {
    return {
        render: (context) => createReactTemplateElement(templateRef, context, ngZone, additionalProps),
    };
}
/**
 * Wrap a function resolving to an `HTMLElement` with a `JSX.Element`.
 *
 * @param htmlRenderFunc The function to wrap
 * @param additionalProps optional additional props to pass to the `ReactContent` object that will render the content.
 */
function createHtmlRenderer(htmlRenderFunc, additionalProps) {
    return {
        render: context => {
            const rootHtmlElement = htmlRenderFunc(context);
            return renderReactContent([rootHtmlElement], additionalProps);
        },
    };
}
/**
 * Wrap a `ComponentRef` with a `JSX.Element`.
 *
 * @param htmlRenderFunc The component reference to wrap
 * @param additionalProps optional additional props to pass to the `ReactContent` object that will render the content.
 */
function createComponentRenderer(componentRef, additionalProps) {
    let renderedJsx = null;
    return {
        render: context => {
            if (!renderedJsx) {
                renderedJsx = renderReactContent([componentRef.location.nativeElement], additionalProps);
            }
            Object.assign(componentRef.instance, context);
            componentRef.changeDetectorRef.detectChanges();
            return renderedJsx;
        },
    };
}

function isRenderComponentOptions(x) {
    if (typeof x !== 'object') {
        return false;
    }
    const maybeRenderComponentOptions = x;
    return (maybeRenderComponentOptions.componentType != null &&
        maybeRenderComponentOptions.factoryResolver != null &&
        maybeRenderComponentOptions.injector != null);
}
function isRenderPropOptions(x) {
    if (typeof x !== 'object') {
        return false;
    }
    const maybeRenderPropOptions = x;
    return maybeRenderPropOptions.getProps && typeof maybeRenderPropOptions.getProps === 'function';
}
function createInputJsxRenderer(input, ngZone, additionalProps) {
    if (input instanceof TemplateRef) {
        const templateRenderer = createTemplateRenderer(input, ngZone, additionalProps);
        return (context) => templateRenderer.render(context);
    }
    if (input instanceof ComponentRef) {
        const componentRenderer = createComponentRenderer(input, additionalProps);
        return (context) => componentRenderer.render(context);
    }
    if (input instanceof Function) {
        const htmlRenderer = createHtmlRenderer(input, additionalProps);
        return (context) => htmlRenderer.render(context);
    }
    if (isRenderComponentOptions(input)) {
        const { componentType, factoryResolver, injector } = input;
        const componentFactory = factoryResolver.resolveComponentFactory(componentType);
        const componentRef = componentFactory.create(injector);
        // Call the function again with the created ComponentRef<TContext>
        return createInputJsxRenderer(componentRef, ngZone, additionalProps);
    }
}
function createRenderPropHandler(renderInputValue, ngZone, options) {
    if (isRenderPropContext(renderInputValue)) {
        return renderInputValue.render;
    }
    if (isRenderPropOptions(renderInputValue)) {
        return (props, defaultRender) => {
            return typeof defaultRender === 'function' ? defaultRender(renderInputValue.getProps(props)) : null;
        };
    }
    const renderer = (options && options.jsxRenderer) ||
        createInputJsxRenderer(renderInputValue, ngZone, options && options.additionalProps);
    return (props, defaultRender) => {
        if (!renderInputValue) {
            return typeof defaultRender === 'function' ? defaultRender(props) : null;
        }
        return renderer(props);
    };
}

// Copyright (c) Microsoft Corporation. All rights reserved.
// Forbidden attributes are still ignored, since they may be set from the wrapper components themselves (forbidden is only applied for users of the wrapper components)
const ignoredAttributeMatchers = [/^_?ng-?.*/, /^style$/, /^class$/];
const ngClassRegExp = /^ng-/;
const defaultWrapperComponentOptions = {
    setHostDisplay: false,
};
/**
 * Base class for Angular @Components wrapping React Components.
 * Simplifies some of the handling around passing down props and CSS styling on the host component.
 */
// NOTE: TProps is not used at the moment, but a preparation for a potential future change.
class ReactWrapperComponent {
    /**
     * Creates an instance of ReactWrapperComponent.
     * @param elementRef The host element.
     * @param changeDetectorRef The change detector for the component.
     * @param renderer The Angular renderer.
     */
    constructor(elementRef, changeDetectorRef, renderer, { setHostDisplay, ngZone } = defaultWrapperComponentOptions) {
        this.elementRef = elementRef;
        this.changeDetectorRef = changeDetectorRef;
        this.renderer = renderer;
        this._ngZone = ngZone;
        this._shouldSetHostDisplay = setHostDisplay;
    }
    /**
     * Alternative to `class` and `[ngClass]` using the same syntax.
     *
     * @description Since this is a wrapper component, sticking to the virtual DOM concept, its DOM element shouldn't have any styling of its own.
     * Instead, any value passes to `contentClass` will be passed to the root component's class as `className`.
     */
    set contentClass(value) {
        this._contentClass = value;
        if (isReactNode(this.reactNodeRef.nativeElement)) {
            this.reactNodeRef.nativeElement.setProperty('className', classnames(value));
            this.markForCheck();
        }
    }
    get contentClass() {
        return this._contentClass;
    }
    /**
     * Alternative to `style` and `[ngStyle]` using (almost) the same syntax.
     * All syntax supports by `ngStyle` is supported, with the exception of specifying units in the key (`{ 'width.px': 12 }`).
     *
     * @description Since this is a wrapper component, sticking to the virtual DOM concept, this should have any styling of its own.
     * Any value passes to `contentStyle` will be passed to the root component's style.
     */
    set contentStyle(value) {
        this._contentStyle = value;
        if (isReactNode(this.reactNodeRef.nativeElement)) {
            const stringValue = typeof value === 'string' ? value : stylenames(value);
            this.reactNodeRef.nativeElement.setProperty('style', toStyle(stringValue));
            this.markForCheck();
        }
    }
    get contentStyle() {
        return this._contentStyle;
    }
    ngAfterContentInit() {
        this._passAttributesAsProps();
    }
    ngAfterViewInit() {
        if (this._shouldSetHostDisplay) {
            this._setHostDisplay();
        }
        // NOTE: Workaround/fix for Issue #5 (https://github.com/Microsoft/angular-react/issues/5).
        // The wrapper component isn't added to the root react nodes list when it's inside a `ReactContent` node, we manually add it (note that the root nodes list is a `Set`, so it won't duplicate nodes if already exist).
        // There's potentially a better solution instead of this
        const rendererData = this.renderer.data;
        if (isReactRendererData(rendererData)) {
            afterRenderFinished(() => {
                const nativeElement = this.reactNodeRef.nativeElement;
                if (isReactNode(nativeElement)) {
                    rendererData.addRootNode(nativeElement);
                }
            });
        }
    }
    ngOnChanges(changes) {
        this._passAttributesAsProps();
        this.markForCheck();
    }
    /**
     * Mark the component as one that needed re-rendering on the React side,
     * and mark for change detection on the Angular side.
     */
    markForCheck() {
        if (isReactNode(this.reactNodeRef.nativeElement)) {
            this.reactNodeRef.nativeElement.setRenderPending();
        }
        this.changeDetectorRef.markForCheck();
    }
    /**
     * Create an JSX renderer for an `@Input` property.
     * @param input The input property.
     * @param additionalProps optional additional props to pass to the `ReactContent` object that will render the content.
     */
    createInputJsxRenderer(input, additionalProps) {
        if (input === undefined) {
            return undefined;
        }
        if (!this._ngZone) {
            throw new Error('To create an input JSX renderer you must pass an NgZone to the constructor.');
        }
        return createInputJsxRenderer(input, this._ngZone, additionalProps);
    }
    /**
     * Create an event handler for a render prop
     * @param renderInputValue the value of the render `@Input` property.
     * @param jsxRenderer an optional renderer to use.
     * @param additionalProps optional additional props to pass to the `ReactContent` object that will render the content.
     */
    createRenderPropHandler(renderInputValue, options) {
        return createRenderPropHandler(renderInputValue, this._ngZone, options);
    }
    _passAttributesAsProps() {
        const hostAttributes = Array.from(this.elementRef.nativeElement.attributes);
        if (!this.reactNodeRef || !isReactNode(this.reactNodeRef.nativeElement)) {
            throw new Error('reactNodeRef must hold a reference to a ReactNode');
        }
        // Ensure there are no blacklisted props. Suggest alternative as error if there is any
        hostAttributes.forEach(attr => {
            const [forbidden, alternativeAttrName] = this._isForbiddenAttribute(attr);
            if (forbidden) {
                throw new Error(`[${this.elementRef
                    .nativeElement.tagName.toLowerCase()}] React wrapper components cannot have the '${attr.name}' attribute set. Use the following alternative: ${alternativeAttrName || ''}`);
            }
        });
        const whitelistedHostAttributes = hostAttributes.filter(attr => !this._isIgnoredAttribute(attr));
        const props = whitelistedHostAttributes.reduce((acc, attr) => (Object.assign({}, acc, { [attr.name]: attr.value })), {});
        const eventListeners = this.elementRef.nativeElement.getEventListeners();
        const eventHandlersProps = eventListeners && Object.keys(eventListeners).length
            ? toObject(Object.values(eventListeners).map(([eventListener]) => [
                eventListener.type,
                (ev) => eventListener.listener(ev && ev.nativeEvent),
            ]))
            : {};
        this.reactNodeRef.nativeElement.setProperties(Object.assign({}, props, eventHandlersProps));
    }
    _setHostDisplay() {
        const nativeElement = this.elementRef.nativeElement;
        // We want to wait until child elements are rendered
        requestAnimationFrame(() => {
            if (nativeElement.firstElementChild) {
                const rootChildDisplay = getComputedStyle(nativeElement.firstElementChild).display;
                nativeElement.style.display = rootChildDisplay;
            }
        });
    }
    _isIgnoredAttribute(attr) {
        return ignoredAttributeMatchers.some(regExp => regExp.test(attr.name));
    }
    _isForbiddenAttribute(attr) {
        const { name, value } = attr;
        if (name === 'key')
            return [true, undefined];
        if (name === 'class' && value.split(' ').some(className => !ngClassRegExp.test(className)))
            return [true, 'contentClass'];
        if (name === 'style') {
            const style = toStyle(value);
            // Only allowing style if it's something that changes the display - setting anything else should be done on the child component directly (via the `styles` attribute in fabric for example)
            if (Object.entries(style).filter(([key, value]) => value && key !== 'display').length > 0) {
                return [true, 'contentStyle'];
            }
        }
        return [false, undefined];
    }
}
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], ReactWrapperComponent.prototype, "contentClass", null);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], ReactWrapperComponent.prototype, "contentStyle", null);

export { AngularReactBrowserModule, Disguise, ReactContent, ReactTemplate, ReactWrapperComponent, createReactContentElement, createReactTemplateElement, getPassProps, passProp, registerElement, passPropsSymbol as ɵa, AngularReactRendererFactory as ɵb };
//# sourceMappingURL=angular-react-core.js.map
