import { NgZone, TemplateRef } from '@angular/core';
import * as React from 'react';
/**
 * @internal
 */
export interface ReactTemplateProps {
    /**
     * Use the legacy rendering mode.
     *
     * Uses a similar approach to `router-outlet`, where the child elements are added to the parent, instead of this node, and this is hidden.
     *
     * @default false
     */
    legacyRenderMode?: boolean;
}
/**
 * Creates a new `ReactTemplate` element.
 * @param templateRef The template to render.
 * @param context The context to inject the template.
 * @param ngZone A zone used for tracking changes in the template.
 * @param additionalProps _Optional_. @see `ReactTemplateProps`.
 */
export declare function createReactTemplateElement<TContext extends object | void>(templateRef: TemplateRef<TContext>, context: TContext, ngZone: NgZone, additionalProps?: ReactTemplateProps): React.ComponentElement<InternalReactTemplateProps<void | object>, ReactTemplate<void | object>>;
/**
 * @internal
 */
interface InternalReactTemplateProps<TContext extends object | void> extends ReactTemplateProps {
    ngZone: NgZone;
    templateRef: TemplateRef<TContext>;
    context: TContext;
}
/**
 * Render an `ng-template` as a child of a React component.
 * Supports two rendering modes:
 *  1. `legacy` - append `<react-content>` as the root, and nest the `children-to-append` underneath it.
 *  2. `new` (**default**) - append the `children-to-append` to the parent of this component, and hide the `<react-content>` element.
 *     (similar to how `router-outlet` behaves in Angular).
 */
export declare class ReactTemplate<TContext extends object | void> extends React.Component<InternalReactTemplateProps<TContext>> {
    private _embeddedViewRef;
    private _ngZoneSubscription;
    componentDidUpdate(): void;
    componentDidMount(): void;
    componentWillUnmount(): void;
    render(): React.ReactElement<{
        style: {
            display: string;
        };
    }>;
}
export {};
