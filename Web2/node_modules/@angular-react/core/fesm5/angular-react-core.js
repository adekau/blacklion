import { __read, __assign, __extends, __rest, __decorate, __metadata } from 'tslib';
import { Injectable, RendererStyleFlags2, NgModule, TemplateRef, ComponentRef, Input } from '@angular/core';
import { EventManager, ɵDomSharedStylesHost, ɵDomRendererFactory2, BrowserModule } from '@angular/platform-browser';
import { createElement, PureComponent, Children, Fragment, Component } from 'react';
import { findDOMNode, unmountComponentAtNode, render } from 'react-dom';
import classnames from 'classnames';
import toStyle from 'css-to-style';
import stylenames from 'stylenames';
import { throttleTime } from 'rxjs/operators';

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var passPropsSymbol = Symbol('passProps');
function passPropImpl(target, propertyKey, targetKey) {
    if (!target[passPropsSymbol]) {
        target[passPropsSymbol] = [];
    }
    target[passPropsSymbol].push({
        sourceKey: propertyKey,
        targetKey: targetKey,
    });
}
var passPropRename = function (propName) { return function (target, propertyKey) {
    return passPropImpl(target, propertyKey, propName);
}; };
var passPropDirect = function (target, propertyKey) { return passPropImpl(target, propertyKey, propertyKey); };
function passProp() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    if (args.length === 0) {
        return passPropDirect;
    }
    if (args.length === 1) {
        return passPropRename(args[0]);
    }
    throw new Error('[passProp] Only 0 or 1 arguments accepted.');
}
function getPassProps(obj) {
    return obj[passPropsSymbol];
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * Remove all undefined properties from obj.
 *
 * Does **not** modify the original object.
 * @returns A clone of `obj`, with all `undefined` properties removed
 */
var removeUndefinedProperties = function (obj) {
    return Object.entries(obj).reduce(function (acc, _a) {
        var _b;
        var _c = __read(_a, 2), key = _c[0], value = _c[1];
        if (value === undefined)
            return acc;
        return Object.assign(acc, (_b = {}, _b[key] = value, _b));
    }, {});
};

/**
 * Checks if a node is in the DOM.
 *
 * @param node The node to check
 * @returns whether the node is in the DOM
 */
var isNodeInDOM = function (node) { return node.isConnected || document.body.contains(node); };

// Copyright (c) Microsoft Corporation. All rights reserved.
var CHILDREN_TO_APPEND_PROP = 'children-to-append';
/**
 * Creates a new `ReactContent` element.
 * @param children The children to append to the `ReactContent` element.
 * @param additionalProps _Optional_. @see `ReactContentProps`.
 */
function createReactContentElement(children, additionalProps) {
    var _a;
    return createElement(ReactContent, __assign({}, additionalProps, (_a = {}, _a[CHILDREN_TO_APPEND_PROP] = children, _a)));
}
/**
 * Render any `HTMLElement`s as a child of React components.
 * Supports two rendering modes:
 *  1. `legacy` - append `<react-content>` as the root, and nest the `children-to-append` underneath it.
 *  2. `new` (**default**) - append the `children-to-append` to the parent of this component, and hide the `<react-content>` element.
 *     (similar to how `router-outlet` behaves in Angular).
 */
var ReactContent = /** @class */ (function (_super) {
    __extends(ReactContent, _super);
    function ReactContent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ReactContent.prototype.componentDidMount = function () {
        var element = findDOMNode(this);
        if (this.props[CHILDREN_TO_APPEND_PROP]) {
            var hostElement_1 = this.props.legacyRenderMode ? element : element.parentElement;
            // Only add children not already in the DOM
            this.props[CHILDREN_TO_APPEND_PROP].filter(function (child) { return !isNodeInDOM(child); }).forEach(function (child) {
                return hostElement_1.appendChild(child);
            });
        }
    };
    ReactContent.prototype.render = function () {
        // TODO: See if we can just render React.Fragment and the children within it, having no extra DOM nodes.
        return createElement('react-content', !this.props.legacyRenderMode && { style: { display: 'none' } });
    };
    return ReactContent;
}(PureComponent));

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * A React component that can render a component and its children as other component types.
 */
var Disguise = /** @class */ (function (_super) {
    __extends(Disguise, _super);
    function Disguise() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Disguise.prototype.render = function () {
        var _a = this.props, disguiseRootAs = _a.disguiseRootAs, disguiseChildrenAs = _a.disguiseChildrenAs, children = _a.children, ngChildComponents = _a.ngChildComponents, rest = __rest(_a, ["disguiseRootAs", "disguiseChildrenAs", "children", "ngChildComponents"]);
        var Root = disguiseRootAs || Fragment;
        var renderedChildren = ngChildComponents
            ? this._isReactContentOnlyChild()
                ? this._renderReactContentChildren()
                : this._renderChildrenNaive()
            : children;
        return createElement(Root, rest || null, renderedChildren);
    };
    Disguise.prototype._isReactContentOnlyChild = function () {
        var children = this.props.children;
        if (Children.count(children) === 1) {
            var _a = __read(Children.toArray(children), 1), onlyChild = _a[0];
            if (typeof onlyChild === 'object' && onlyChild.type === ReactContent) {
                return true;
            }
        }
        return false;
    };
    Disguise.prototype._renderReactContentChildren = function () {
        var _a = this.props, ngChildComponents = _a.ngChildComponents, disguiseChildrenAs = _a.disguiseChildrenAs;
        var renderedChildren = ngChildComponents.map(function (child, index) {
            var propsToPass = removeUndefinedProperties(getPassProps(child).reduce(function (acc, passProp) {
                var _a;
                return Object.assign(acc, (_a = {}, _a[passProp.targetKey] = child[passProp.sourceKey], _a));
            }, {}));
            return createElement(disguiseChildrenAs, __assign({}, propsToPass, { key: index, ref: function (childReactElement) {
                    // ref callback is called with null when the component unmounts from the DOM, we don't need to handle it.
                    if (!childReactElement) {
                        return;
                    }
                    findDOMNode(childReactElement).appendChild(child.elementRef.nativeElement);
                } }));
        });
        return renderedChildren;
    };
    Disguise.prototype._renderChildrenNaive = function () {
        var _a = this.props, children = _a.children, disguiseChildrenAs = _a.disguiseChildrenAs;
        var renderedChildren = Children.map(children, function (child) {
            if (!disguiseChildrenAs || typeof child !== 'object') {
                return child;
            }
            var ChildRoot = child.type || disguiseChildrenAs;
            return createElement(ChildRoot, __assign({}, child.props, { key: child.key }), child);
        });
        return renderedChildren;
    };
    return Disguise;
}(PureComponent));

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var elementMap = new Map();
var camelCaseSplit = /([a-z0-9])([A-Z])/g;
/**
 * Register an element to be renderer when the renderer sees the tag.
 * @param elementName the tag to be used to get the component type when rendering.
 * @param resolver A resolver to the React component.
 */
function registerElement(elementName, resolver) {
    if (elementMap.has(elementName)) {
        // Ignore multiple register attempts for the same component.
        // Angular doesn't allow sharing whole NgModule instances (in this case, an @NgModule for React-wrapped components) with lazy-loaded @NgModules (in the app),
        // To keep the API simple, allow multiple calls to `registerElement`.
        // Disadvantage is that you can't replace (React) component implementations at runtime. This sounds far-fetched, but solvable with a `static forRoot()` pattern for every
        // React-wrapper components' @NgModule, ensuring that `registerElement` is only called once.
        return;
    }
    else {
        var entry = { resolver: resolver };
        elementMap.set(elementName, entry);
        elementMap.set(elementName.toLowerCase(), entry);
        elementMap.set(elementName.replace(camelCaseSplit, '$1-$2').toLowerCase(), entry);
    }
}
function getComponentClass(elementName) {
    var entry = elementMap.get(elementName) || elementMap.get(elementName.toLowerCase());
    if (!entry) {
        // throw new TypeError(`No known component for element ${elementName}.`);
        return elementName;
    }
    try {
        return entry.resolver();
    }
    catch (e) {
        throw new TypeError("Could not load component for: " + elementName + "." + e);
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
function isReactNode(node) {
    return node.setRenderPendingCallback !== undefined;
}
/**
 * Logical representation of everything needed to render a React element in the
 * DOM, with the needed methods to do so.
 */
var ReactNode = /** @class */ (function () {
    function ReactNode(type) {
        this.type = type;
        // Access to these properties are restricted through setters and functions
        // so that the dirty "render pending" state of this object can be properly
        // tracked and all nodes with "render pending" can be flushed at the end
        // of a render operation.
        this._props = {};
        this._children = [];
        this._childrenToAppend = [];
        this._isDestroyPending = false;
        this._isRenderPending = true;
        this.setRenderPendingCallback = function () { return null; };
        this.setRenderPending();
        this._tryResolveTypeIsReactElementClass();
    }
    Object.defineProperty(ReactNode.prototype, "domElement", {
        get: function () {
            return this._renderedDomElement;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ReactNode.prototype, "parent", {
        get: function () {
            return this._parent;
        },
        set: function (parent) {
            this._parent = parent;
            this.setRenderPending();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ReactNode.prototype, "shouldRender", {
        get: function () {
            return !this._isNotRenderable;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ReactNode.prototype, "destroyPending", {
        get: function () {
            return this._isDestroyPending;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Track all pending render operations internally and set flag on
     * renderer factory so that a flush operation can be scheduled for
     * the "end" of render.
     */
    ReactNode.prototype.setRenderPending = function () {
        this.setRenderPendingCallback();
        this._isRenderPending = true;
    };
    /**
     * Marks the node to be removed from the DOM in the next render cycle.
     */
    ReactNode.prototype.destroyNode = function () {
        this.setRenderPending();
        this._isDestroyPending = true;
    };
    /**
     * Sets an attribute on the node.
     * @note the value can only be a `string`. See `setProperty` for other use-cases.
     * @see `Renderer2#setAttribute`.
     *
     * @param name The attribute name.
     * @param value The new value.
     */
    ReactNode.prototype.setAttribute = function (name, value) {
        var _a;
        this.setAttributes((_a = {}, _a[name] = value, _a));
    };
    /**
     * Set attributes on this node.
     * Note that values can only be of type `string`. See `setProperties` for other use-cases.
     * @see `Renderer2#setAttribute`.
     *
     * @param attributes the attributes to set.
     */
    ReactNode.prototype.setAttributes = function (attributes) {
        this.setProperties(attributes);
    };
    /**
     * Sets a prop in the underlying React element.
     * @see `Renderer2#setProperty`.
     *
     * @param name The property name.
     * @param value The new value.
     */
    ReactNode.prototype.setProperty = function (name, value) {
        var _a;
        this.setProperties((_a = {}, _a[name] = value, _a));
    };
    /**
     * Like `setProperty` but for multiple props at once.
     *
     * @param properties An object with the props.
     */
    ReactNode.prototype.setProperties = function (properties) {
        this.setRenderPending();
        Object.assign(this._props, removeUndefinedProperties(properties));
    };
    /**
     * Remove a prop or an attribute from the underlying React element.
     * @see `Renderer2#removeAttribute`.
     *
     * @param name The property name.
     * @param childName _Optional_ A property of `name` to remove instead.
     * @returns the deleted property
     */
    ReactNode.prototype.removeProperty = function (name, childName) {
        this.setRenderPending();
        if (childName) {
            return delete this._props[name][childName];
        }
        return delete this._props[name];
    };
    /**
     * Add a direct child of this node.
     * @see `Renderer2#addChild`.
     *
     * @param node The node to add.
     */
    ReactNode.prototype.addChild = function (node) {
        this.setRenderPending();
        this._children.push(node);
    };
    /**
     * Remove a direct child of this node.
     * @see `Renderer2#removeChild`.
     *
     * @param node The node to remove.
     */
    ReactNode.prototype.removeChild = function (node) {
        this.setRenderPending();
        this._children = this._children.filter(function (child) { return child !== node; });
    };
    /**
     * Cast the node to a comment node.
     * @see `Renderer2#createComment`.
     *
     * @param value the text in the comment to render.
     * @returns itself.
     */
    ReactNode.prototype.asComment = function (value) {
        this.setRenderPending();
        this.type = undefined;
        this._comment = value;
        return this;
    };
    /**
     * Cast the node to a text node.
     * @see `Renderer2#createText`.
     *
     * @param value the text to render.
     * @returns itself.
     */
    ReactNode.prototype.asText = function (value) {
        this.setRenderPending();
        this.type = undefined;
        this._text = value;
        // Skip appending and rendering of empty text nodes. This may cause a bug
        // if a single space is desired...
        if (!value || !value.trim()) {
            this._isNotRenderable = true;
        }
        return this;
    };
    /**
     * Render the node to the DOM, or unmount it, as necessary.
     *
     * @returns itself.
     */
    ReactNode.prototype.render = function () {
        // Only complete render operations for ReactNodes that are parented by HTMLElements.
        // Those that are parented by other ReactNodes will be rendered recursively by their
        // parent.
        if (!isReactNode(this._parent)) {
            if (this._isDestroyPending && this._parent) {
                unmountComponentAtNode(this._parent);
                return this;
            }
            if (this._isRenderPending) {
                // It is expected that the element will be recreated and re-rendered with each attribute change.
                // See: https://reactjs.org/docs/rendering-elements.html
                render(this._renderRecursive(), this._parent);
                this._isRenderPending = false;
            }
        }
        return this;
    };
    /**
     * Appends a child.
     *
     * @see `Renderer2#appendChild`.
     * @note This is called by Angular core when projected content is being added.
     *
     * @param projectedContent the content to project.
     */
    ReactNode.prototype.appendChild = function (projectedContent) {
        this._childrenToAppend.push(projectedContent);
    };
    /**
     * @note for easier debugging.
     */
    ReactNode.prototype.toString = function () {
        if (this._typeName) {
            return "[" + this._typeName + " ReactNode]";
        }
        if (this._text) {
            return '[text ReactNode]';
        }
        if (this._comment) {
            return '[comment ReactNode]';
        }
        return '[undefined ReactNode]';
    };
    ReactNode.prototype._renderRecursive = function (key) {
        var children = this._children
            ? this._children.map(function (child, index) { return child._renderRecursive(index.toString()); })
            : [];
        if (this._text) {
            return this._text;
        }
        this._props[CHILDREN_TO_APPEND_PROP] = this._childrenToAppend;
        if (key) {
            this._props['key'] = key;
        }
        // Just having some props on a React element can cause it to
        // behave undesirably, and since the templates are hard-coded to pass
        // all Inputs all the time, they pass `undefined` values too.
        // This ensures these are removed.
        // Additionally, there are some things that Angular templating forbids,
        // and stops at-compile time (with errors), such as `Input`s being prefixed with `on`.
        // Since React does not have the notion of `Output`s as Angular (they are just props of type function, essentially callbacks).
        // To work around this, we, by convention, prefix any PascalCased prop with `on` here, after the template has already been compiled.
        var clearedProps = this._transformProps(removeUndefinedProperties(this._props));
        return createElement(this.type, clearedProps, children.length > 0 ? children : undefined);
    };
    ReactNode.prototype._transformProps = function (props) {
        var _this = this;
        return Object.entries(props).reduce(function (acc, _a) {
            var _b;
            var _c = __read(_a, 2), key = _c[0], value = _c[1];
            var _d = __read(typeof key !== 'string' ? [key, value] : _this._transformProp(key, value), 2), newKey = _d[0], newValue = _d[1];
            return Object.assign(acc, (_b = {}, _b[newKey] = newValue, _b));
        }, {});
    };
    ReactNode.prototype._transformProp = function (name, value) {
        // prop name is camelCased already
        var firstLetter = name[0];
        if (firstLetter === firstLetter.toLowerCase()) {
            return [name, value];
        }
        // prop name is PascalCased & is a function - assuming render prop or callback prop that has return value
        // NOTE: Angular doesn't allow passing @Inputs that are prefixed with "on". This is useful for render props and properties representing the "on" state (for example, Toggle).
        // As a convention, any @Input that starts with a capital letter is prefixed with "on" when passed as a prop to the underlying React component.
        return ["on" + name, value];
    };
    ReactNode.prototype._tryResolveTypeIsReactElementClass = function () {
        if (this._typeIsReactElementClass === undefined) {
            // Comments and text have no type.
            if (!this.type) {
                return;
            }
            // Store the name of the type for the toString message (debugging).
            this._typeName = this.type;
            // Attempt to resolve the type as a React Element class name/type.
            // Since Angular templates are just strings, we can't include types in them.
            // Therefore, we use the component registry to resolve the type of a component from a string.
            if (typeof this.type === 'string') {
                this.type = getComponentClass(this.type);
            }
            // If type is still a string, then no React Element matches this string.
            this._typeIsReactElementClass = typeof this.type !== 'string';
        }
    };
    return ReactNode;
}());

/**
 * Monkey-patches `Element`'s `addEventListener` & `removeEventListener` and adds `getEventListeners`.
 * This later allows the renderer to emit any event handlers attached to React-wrapped components as Angular Outputs:
 * ```html
 * <my-component (arbitraryEvent)="onEventHandler($event)"></my-component>
 * ```
 *
 * @note Taken and modified from https://github.com/colxi/getEventListeners to be compiled into ES5, allowing running in older browsers
 **/
Element.prototype['_addEventListener'] = Element.prototype.addEventListener;
Element.prototype['_removeEventListener'] = Element.prototype.removeEventListener;
Element.prototype.addEventListener = function (type, listener, options) {
    if (options === undefined)
        options = false;
    // declare listener
    this._addEventListener(type, listener, options);
    if (!this.eventListenerList)
        this.eventListenerList = {};
    if (!this.eventListenerList[type])
        this.eventListenerList[type] = [];
    // add listener to  event tracking list
    this.eventListenerList[type].push({
        type: type,
        listener: listener,
        useCapture: options,
    });
};
Element.prototype.removeEventListener = function (type, listener, options) {
    if (options === undefined)
        options = false;
    // remove listener
    this._removeEventListener(type, listener, options);
    if (!this.eventListenerList)
        this.eventListenerList = {};
    if (!this.eventListenerList[type])
        this.eventListenerList[type] = [];
    // Find the event in the list, If a listener is registered twice, one
    // with capture and one without, remove each one separately. Removal of
    // a capturing listener does not affect a non-capturing version of the
    // same listener, and vice versa.
    for (var i = 0; i < this.eventListenerList[type].length; i++) {
        if (this.eventListenerList[type][i].listener === listener &&
            this.eventListenerList[type][i].useCapture === options) {
            this.eventListenerList[type].splice(i, 1);
            break;
        }
    }
    // if no more events of the removed event type are left,remove the group
    if (this.eventListenerList[type].length == 0)
        delete this.eventListenerList[type];
};
Element.prototype.getEventListeners = function (type) {
    if (!this.eventListenerList)
        this.eventListenerList = {};
    // return requested listeners type or all them
    if (type === undefined)
        return this.eventListenerList;
    return this.eventListenerList[type];
};
/*
    Element.prototype.clearEventListeners = function(a){
        if(!this.eventListenerList)
            this.eventListenerList = {};
        if(a==undefined){
            for(var x in (this.getEventListeners())) this.clearEventListeners(x);
            return;
        }
        var el = this.getEventListeners(a);
        if(el==undefined)
            return;
        for(var i = el.length - 1; i >= 0; --i) {
            var ev = el[i];
            this.removeEventListener(a, ev.listener, ev.useCapture);
        }
    };
    */

// Copyright (c) Microsoft Corporation. All rights reserved.
var AngularReactRendererFactory = /** @class */ (function (_super) {
    __extends(AngularReactRendererFactory, _super);
    function AngularReactRendererFactory(eventManager, sharedStylesHost) {
        var _this = _super.call(this, eventManager, sharedStylesHost, 'app-id') || this;
        // Collection of ReactNodes that can be evaluated and flushed at the
        // end of Render.  This is necessary as the flow of element creation
        // and update goes from "create" > "insert" > "update" property/attribute.
        // React elements cannot be "inserted" and later have their props
        // updated, so the "insert", or React.Render, can only be done once the
        // element has been fully defined.  Only the topmost [root] nodes are added here.
        _this.reactRootNodes = new Set();
        // This flag can only be set to true from outside.  It can only be reset
        // to false from inside.  This value is reset on "end" when the pending
        // renders are flushed.
        _this.setRenderPendingCallback = function () {
            _this.isRenderPending = true;
        };
        // tslint:disable-next-line: no-use-before-declare
        _this.defaultReactRenderer = new ReactRenderer(_this);
        return _this;
    }
    AngularReactRendererFactory.prototype.createRenderer = function (element, type) {
        if (type && type.styles.length && type.styles[0] === 'react-renderer') {
            return this.defaultReactRenderer;
        }
        return _super.prototype.createRenderer.call(this, element, type);
    };
    AngularReactRendererFactory.prototype.begin = function () { };
    AngularReactRendererFactory.prototype.end = function () {
        // Flush any pending React element render updates.  This cannot be done
        // earlier (as is done for DOM elements) because React element props
        // are ReadOnly.
        if (this.isRenderPending) {
            // Remove root nodes that are pending destroy after render.
            this.reactRootNodes = new Set(Array.from(this.reactRootNodes).filter(function (node) { return !node.render().destroyPending; }));
            this.isRenderPending = false;
        }
    };
    AngularReactRendererFactory = __decorate([
        Injectable(),
        __metadata("design:paramtypes", [EventManager, ɵDomSharedStylesHost])
    ], AngularReactRendererFactory);
    return AngularReactRendererFactory;
}(ɵDomRendererFactory2));
var isReactRendererData = function (data) {
    return data && typeof data.addRootNode === 'function';
};
var ReactRenderer = /** @class */ (function () {
    function ReactRenderer(rootRenderer) {
        var _this = this;
        this.rootRenderer = rootRenderer;
        this.data = {
            addRootNode: function (node) {
                _this.rootRenderer.reactRootNodes.add(node);
            },
        };
        // These two elements are essential for the whole experience to be smooth for the user - register them from the get-go.
        registerElement('ReactContent', function () { return ReactContent; });
        registerElement('Disguise', function () { return Disguise; });
    }
    ReactRenderer.prototype.destroy = function () { };
    ReactRenderer.prototype.destroyNode = function (node) {
        node.destroyNode();
    };
    ReactRenderer.prototype.createElement = function (name, namespace) {
        return new ReactNode(name);
    };
    ReactRenderer.prototype.createComment = function (value) {
        return new ReactNode().asComment(value);
    };
    ReactRenderer.prototype.createText = function (value) {
        return new ReactNode().asText(value);
    };
    ReactRenderer.prototype.appendChild = function (parent, node) {
        // Only append a child if there is a child to append.
        if (!node) {
            return;
        }
        // Don't append empty text nodes.
        if (!node.shouldRender) {
            return;
        }
        // Provide a parent element reference to the ReactNode.  This will be used later
        // once the ReactNode is fully defined and it is subsequently rendered.
        if (!isReactNode(parent)) {
            node.setRenderPendingCallback = this.rootRenderer.setRenderPendingCallback;
            this.rootRenderer.reactRootNodes.add(node);
            node.parent = parent;
            return;
        }
        node.setRenderPendingCallback = function () { return parent.setRenderPending(); };
        parent.addChild(node);
        node.parent = parent;
    };
    ReactRenderer.prototype.insertBefore = function (parent, node, refChild) {
        // Only insert a child if there is a parent.
        if (!parent) {
            return;
        }
        var target = document.createElement('div');
        parent.insertBefore(target, refChild);
        node.parent = target;
        node.setRenderPendingCallback = this.rootRenderer.setRenderPendingCallback;
    };
    ReactRenderer.prototype.removeChild = function (parent, node) {
        // Only insert a child if there is a parent.
        if (!parent) {
            return;
        }
        // Remove a parent element reference from the ReactNode.  This will be later
        // result in the ReactNode unloading itself.
        if (!isReactNode(parent)) {
            node.parent = null;
            return;
        }
        parent.removeChild(node);
    };
    ReactRenderer.prototype.selectRootElement = function (selectorOrNode) {
    };
    ReactRenderer.prototype.parentNode = function (node) {
    };
    ReactRenderer.prototype.nextSibling = function (node) {
    };
    ReactRenderer.prototype.setAttribute = function (node, name, value, namespace) {
        node.setProperty(name, value);
    };
    ReactRenderer.prototype.removeAttribute = function (node, name, namespace) {
        node.removeProperty(name);
    };
    ReactRenderer.prototype.addClass = function (node, name) {
        // Update the virtual node.
        // TODO: This may only support a single class name, but might work if property name is a single
        //       comma-delimited list of classes...
        node.setProperty('className', name);
    };
    ReactRenderer.prototype.removeClass = function (node, name) {
        // Update the virtual node.
        // TODO: This may not work correctly to remove a single name from a comma-delimited list.
        node.removeProperty('className');
    };
    ReactRenderer.prototype.setStyle = function (node, style, value, flags) {
        // if (DEBUG) { console.log('Renderer > setStyle > node: ', node.toString(), 'style:', style, 'value:', value, 'flags:', flags); }
        if (flags & RendererStyleFlags2.DashCase) {
            node.setProperty('style', { style: value + !!(flags & RendererStyleFlags2.Important) ? ' !important' : '' });
        }
        else {
            node.setProperty('style', { style: value });
        }
    };
    ReactRenderer.prototype.removeStyle = function (node, style, flags) {
        node.removeProperty('style', style);
    };
    ReactRenderer.prototype.setProperty = function (node, name, value) {
        node.setProperty(name, value);
    };
    ReactRenderer.prototype.setValue = function (node, value) {
        node.setProperty('value', value);
    };
    ReactRenderer.prototype.listen = function (target, event, callback) {
        target.setProperty(event, callback);
        // TODO: NEEDS WORK: Implement prevent default callback behavior.
        // return <() => void>this.eventManager.addEventListener(
        //            target, event, decoratePreventDefault(callback)) as() => void;
        // tslint:disable-next-line:no-unused-expression
        return function () { return null; };
    };
    return ReactRenderer;
}());

// Copyright (c) Microsoft Corporation. All rights reserved.
var AngularReactBrowserModule = /** @class */ (function () {
    function AngularReactBrowserModule() {
    }
    AngularReactBrowserModule = __decorate([
        NgModule({
            imports: [BrowserModule],
            exports: [BrowserModule],
            providers: [{ provide: ɵDomRendererFactory2, useClass: AngularReactRendererFactory }],
        })
    ], AngularReactBrowserModule);
    return AngularReactBrowserModule;
}());

/**
 * Transforms an array of [key, value] tuples to an object
 */
function toObject(pairs) {
    return pairs.reduce(function (acc, _a) {
        var _b;
        var _c = __read(_a, 2), key = _c[0], value = _c[1];
        return Object.assign(acc, (_b = {},
            _b[key] = value,
            _b));
    }, {});
}

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
/**
 * Delays the execution of a function to be after the next render.
 *
 * @param callback The function to execute
 */
var afterRenderFinished = function (callback) {
    setTimeout(callback, 0);
};

// Copyright (c) Microsoft Corporation. All rights reserved.
var TEMPLATE_DETECT_CHANGES_THROTTLE_MS = 250;
/**
 * Creates a new `ReactTemplate` element.
 * @param templateRef The template to render.
 * @param context The context to inject the template.
 * @param ngZone A zone used for tracking changes in the template.
 * @param additionalProps _Optional_. @see `ReactTemplateProps`.
 */
function createReactTemplateElement(templateRef, context, ngZone, additionalProps) {
    return createElement(ReactTemplate, __assign({ ngZone: ngZone, templateRef: templateRef, context: context }, additionalProps));
}
/**
 * Render an `ng-template` as a child of a React component.
 * Supports two rendering modes:
 *  1. `legacy` - append `<react-content>` as the root, and nest the `children-to-append` underneath it.
 *  2. `new` (**default**) - append the `children-to-append` to the parent of this component, and hide the `<react-content>` element.
 *     (similar to how `router-outlet` behaves in Angular).
 */
var ReactTemplate = /** @class */ (function (_super) {
    __extends(ReactTemplate, _super);
    function ReactTemplate() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ReactTemplate.prototype.componentDidUpdate = function () {
        // Context has changes, trigger change detection after pushing the new context in
        if (this.props.context != null && this._embeddedViewRef.context != null) {
            Object.assign(this._embeddedViewRef.context, this.props.context);
        }
        this._embeddedViewRef.detectChanges();
    };
    ReactTemplate.prototype.componentDidMount = function () {
        var _this = this;
        var _a = this.props, context = _a.context, ngZone = _a.ngZone, templateRef = _a.templateRef;
        this._embeddedViewRef = templateRef.createEmbeddedView(context);
        var element = findDOMNode(this);
        var hostElement = this.props.legacyRenderMode ? element : element.parentElement;
        this._embeddedViewRef.rootNodes.forEach(function (child) { return hostElement.appendChild(child); });
        // Detect the first cycle's changes, and then subscribe for subsequent ones.
        this._embeddedViewRef.detectChanges();
        // Throttling the detect changes to an empirically selected value so we don't overload too much work.
        // TODO: This needs some better solution to listen to changes to the binding sources of the template.
        this._ngZoneSubscription = ngZone.onStable
            .pipe(throttleTime(TEMPLATE_DETECT_CHANGES_THROTTLE_MS, undefined, { leading: true, trailing: true }))
            .subscribe(function () {
            _this._embeddedViewRef.detectChanges();
        });
    };
    ReactTemplate.prototype.componentWillUnmount = function () {
        this._ngZoneSubscription.unsubscribe();
        if (this._embeddedViewRef) {
            this._embeddedViewRef.destroy();
        }
    };
    ReactTemplate.prototype.render = function () {
        // TODO: See if we can just render React.Fragment and the children within it, having no extra DOM nodes.
        return createElement('react-template', !this.props.legacyRenderMode && { style: { display: 'none' } });
    };
    return ReactTemplate;
}(Component));

// Copyright (c) Microsoft Corporation. All rights reserved.
function isRenderPropContext(x) {
    if (typeof x !== 'object') {
        return false;
    }
    var maybeRenderPropContext = x;
    return maybeRenderPropContext.render && typeof maybeRenderPropContext.render === 'function';
}
function renderReactContent(rootNodes, additionalProps) {
    return createReactContentElement(rootNodes, additionalProps);
}
/**
 * Wrap a `TemplateRef` with a `JSX.Element`.
 *
 * @param templateRef The template to wrap
 * @param ngZone A zone used for tracking & triggering updates to the template
 * @param additionalProps optional additional props to pass to the `ReactContent` object that will render the content.
 */
function createTemplateRenderer(templateRef, ngZone, additionalProps) {
    return {
        render: function (context) { return createReactTemplateElement(templateRef, context, ngZone, additionalProps); },
    };
}
/**
 * Wrap a function resolving to an `HTMLElement` with a `JSX.Element`.
 *
 * @param htmlRenderFunc The function to wrap
 * @param additionalProps optional additional props to pass to the `ReactContent` object that will render the content.
 */
function createHtmlRenderer(htmlRenderFunc, additionalProps) {
    return {
        render: function (context) {
            var rootHtmlElement = htmlRenderFunc(context);
            return renderReactContent([rootHtmlElement], additionalProps);
        },
    };
}
/**
 * Wrap a `ComponentRef` with a `JSX.Element`.
 *
 * @param htmlRenderFunc The component reference to wrap
 * @param additionalProps optional additional props to pass to the `ReactContent` object that will render the content.
 */
function createComponentRenderer(componentRef, additionalProps) {
    var renderedJsx = null;
    return {
        render: function (context) {
            if (!renderedJsx) {
                renderedJsx = renderReactContent([componentRef.location.nativeElement], additionalProps);
            }
            Object.assign(componentRef.instance, context);
            componentRef.changeDetectorRef.detectChanges();
            return renderedJsx;
        },
    };
}

function isRenderComponentOptions(x) {
    if (typeof x !== 'object') {
        return false;
    }
    var maybeRenderComponentOptions = x;
    return (maybeRenderComponentOptions.componentType != null &&
        maybeRenderComponentOptions.factoryResolver != null &&
        maybeRenderComponentOptions.injector != null);
}
function isRenderPropOptions(x) {
    if (typeof x !== 'object') {
        return false;
    }
    var maybeRenderPropOptions = x;
    return maybeRenderPropOptions.getProps && typeof maybeRenderPropOptions.getProps === 'function';
}
function createInputJsxRenderer(input, ngZone, additionalProps) {
    if (input instanceof TemplateRef) {
        var templateRenderer_1 = createTemplateRenderer(input, ngZone, additionalProps);
        return function (context) { return templateRenderer_1.render(context); };
    }
    if (input instanceof ComponentRef) {
        var componentRenderer_1 = createComponentRenderer(input, additionalProps);
        return function (context) { return componentRenderer_1.render(context); };
    }
    if (input instanceof Function) {
        var htmlRenderer_1 = createHtmlRenderer(input, additionalProps);
        return function (context) { return htmlRenderer_1.render(context); };
    }
    if (isRenderComponentOptions(input)) {
        var componentType = input.componentType, factoryResolver = input.factoryResolver, injector = input.injector;
        var componentFactory = factoryResolver.resolveComponentFactory(componentType);
        var componentRef = componentFactory.create(injector);
        // Call the function again with the created ComponentRef<TContext>
        return createInputJsxRenderer(componentRef, ngZone, additionalProps);
    }
}
function createRenderPropHandler(renderInputValue, ngZone, options) {
    if (isRenderPropContext(renderInputValue)) {
        return renderInputValue.render;
    }
    if (isRenderPropOptions(renderInputValue)) {
        return function (props, defaultRender) {
            return typeof defaultRender === 'function' ? defaultRender(renderInputValue.getProps(props)) : null;
        };
    }
    var renderer = (options && options.jsxRenderer) ||
        createInputJsxRenderer(renderInputValue, ngZone, options && options.additionalProps);
    return function (props, defaultRender) {
        if (!renderInputValue) {
            return typeof defaultRender === 'function' ? defaultRender(props) : null;
        }
        return renderer(props);
    };
}

// Copyright (c) Microsoft Corporation. All rights reserved.
// Forbidden attributes are still ignored, since they may be set from the wrapper components themselves (forbidden is only applied for users of the wrapper components)
var ignoredAttributeMatchers = [/^_?ng-?.*/, /^style$/, /^class$/];
var ngClassRegExp = /^ng-/;
var defaultWrapperComponentOptions = {
    setHostDisplay: false,
};
/**
 * Base class for Angular @Components wrapping React Components.
 * Simplifies some of the handling around passing down props and CSS styling on the host component.
 */
// NOTE: TProps is not used at the moment, but a preparation for a potential future change.
var ReactWrapperComponent = /** @class */ (function () {
    /**
     * Creates an instance of ReactWrapperComponent.
     * @param elementRef The host element.
     * @param changeDetectorRef The change detector for the component.
     * @param renderer The Angular renderer.
     */
    function ReactWrapperComponent(elementRef, changeDetectorRef, renderer, _a) {
        var _b = _a === void 0 ? defaultWrapperComponentOptions : _a, setHostDisplay = _b.setHostDisplay, ngZone = _b.ngZone;
        this.elementRef = elementRef;
        this.changeDetectorRef = changeDetectorRef;
        this.renderer = renderer;
        this._ngZone = ngZone;
        this._shouldSetHostDisplay = setHostDisplay;
    }
    Object.defineProperty(ReactWrapperComponent.prototype, "contentClass", {
        get: function () {
            return this._contentClass;
        },
        /**
         * Alternative to `class` and `[ngClass]` using the same syntax.
         *
         * @description Since this is a wrapper component, sticking to the virtual DOM concept, its DOM element shouldn't have any styling of its own.
         * Instead, any value passes to `contentClass` will be passed to the root component's class as `className`.
         */
        set: function (value) {
            this._contentClass = value;
            if (isReactNode(this.reactNodeRef.nativeElement)) {
                this.reactNodeRef.nativeElement.setProperty('className', classnames(value));
                this.markForCheck();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ReactWrapperComponent.prototype, "contentStyle", {
        get: function () {
            return this._contentStyle;
        },
        /**
         * Alternative to `style` and `[ngStyle]` using (almost) the same syntax.
         * All syntax supports by `ngStyle` is supported, with the exception of specifying units in the key (`{ 'width.px': 12 }`).
         *
         * @description Since this is a wrapper component, sticking to the virtual DOM concept, this should have any styling of its own.
         * Any value passes to `contentStyle` will be passed to the root component's style.
         */
        set: function (value) {
            this._contentStyle = value;
            if (isReactNode(this.reactNodeRef.nativeElement)) {
                var stringValue = typeof value === 'string' ? value : stylenames(value);
                this.reactNodeRef.nativeElement.setProperty('style', toStyle(stringValue));
                this.markForCheck();
            }
        },
        enumerable: true,
        configurable: true
    });
    ReactWrapperComponent.prototype.ngAfterContentInit = function () {
        this._passAttributesAsProps();
    };
    ReactWrapperComponent.prototype.ngAfterViewInit = function () {
        var _this = this;
        if (this._shouldSetHostDisplay) {
            this._setHostDisplay();
        }
        // NOTE: Workaround/fix for Issue #5 (https://github.com/Microsoft/angular-react/issues/5).
        // The wrapper component isn't added to the root react nodes list when it's inside a `ReactContent` node, we manually add it (note that the root nodes list is a `Set`, so it won't duplicate nodes if already exist).
        // There's potentially a better solution instead of this
        var rendererData = this.renderer.data;
        if (isReactRendererData(rendererData)) {
            afterRenderFinished(function () {
                var nativeElement = _this.reactNodeRef.nativeElement;
                if (isReactNode(nativeElement)) {
                    rendererData.addRootNode(nativeElement);
                }
            });
        }
    };
    ReactWrapperComponent.prototype.ngOnChanges = function (changes) {
        this._passAttributesAsProps();
        this.markForCheck();
    };
    /**
     * Mark the component as one that needed re-rendering on the React side,
     * and mark for change detection on the Angular side.
     */
    ReactWrapperComponent.prototype.markForCheck = function () {
        if (isReactNode(this.reactNodeRef.nativeElement)) {
            this.reactNodeRef.nativeElement.setRenderPending();
        }
        this.changeDetectorRef.markForCheck();
    };
    /**
     * Create an JSX renderer for an `@Input` property.
     * @param input The input property.
     * @param additionalProps optional additional props to pass to the `ReactContent` object that will render the content.
     */
    ReactWrapperComponent.prototype.createInputJsxRenderer = function (input, additionalProps) {
        if (input === undefined) {
            return undefined;
        }
        if (!this._ngZone) {
            throw new Error('To create an input JSX renderer you must pass an NgZone to the constructor.');
        }
        return createInputJsxRenderer(input, this._ngZone, additionalProps);
    };
    /**
     * Create an event handler for a render prop
     * @param renderInputValue the value of the render `@Input` property.
     * @param jsxRenderer an optional renderer to use.
     * @param additionalProps optional additional props to pass to the `ReactContent` object that will render the content.
     */
    ReactWrapperComponent.prototype.createRenderPropHandler = function (renderInputValue, options) {
        return createRenderPropHandler(renderInputValue, this._ngZone, options);
    };
    ReactWrapperComponent.prototype._passAttributesAsProps = function () {
        var _this = this;
        var hostAttributes = Array.from(this.elementRef.nativeElement.attributes);
        if (!this.reactNodeRef || !isReactNode(this.reactNodeRef.nativeElement)) {
            throw new Error('reactNodeRef must hold a reference to a ReactNode');
        }
        // Ensure there are no blacklisted props. Suggest alternative as error if there is any
        hostAttributes.forEach(function (attr) {
            var _a = __read(_this._isForbiddenAttribute(attr), 2), forbidden = _a[0], alternativeAttrName = _a[1];
            if (forbidden) {
                throw new Error("[" + _this.elementRef
                    .nativeElement.tagName.toLowerCase() + "] React wrapper components cannot have the '" + attr.name + "' attribute set. Use the following alternative: " + (alternativeAttrName || ''));
            }
        });
        var whitelistedHostAttributes = hostAttributes.filter(function (attr) { return !_this._isIgnoredAttribute(attr); });
        var props = whitelistedHostAttributes.reduce(function (acc, attr) {
            var _a;
            return (__assign({}, acc, (_a = {}, _a[attr.name] = attr.value, _a)));
        }, {});
        var eventListeners = this.elementRef.nativeElement.getEventListeners();
        var eventHandlersProps = eventListeners && Object.keys(eventListeners).length
            ? toObject(Object.values(eventListeners).map(function (_a) {
                var _b = __read(_a, 1), eventListener = _b[0];
                return [
                    eventListener.type,
                    function (ev) { return eventListener.listener(ev && ev.nativeEvent); },
                ];
            }))
            : {};
        this.reactNodeRef.nativeElement.setProperties(__assign({}, props, eventHandlersProps));
    };
    ReactWrapperComponent.prototype._setHostDisplay = function () {
        var nativeElement = this.elementRef.nativeElement;
        // We want to wait until child elements are rendered
        requestAnimationFrame(function () {
            if (nativeElement.firstElementChild) {
                var rootChildDisplay = getComputedStyle(nativeElement.firstElementChild).display;
                nativeElement.style.display = rootChildDisplay;
            }
        });
    };
    ReactWrapperComponent.prototype._isIgnoredAttribute = function (attr) {
        return ignoredAttributeMatchers.some(function (regExp) { return regExp.test(attr.name); });
    };
    ReactWrapperComponent.prototype._isForbiddenAttribute = function (attr) {
        var name = attr.name, value = attr.value;
        if (name === 'key')
            return [true, undefined];
        if (name === 'class' && value.split(' ').some(function (className) { return !ngClassRegExp.test(className); }))
            return [true, 'contentClass'];
        if (name === 'style') {
            var style = toStyle(value);
            // Only allowing style if it's something that changes the display - setting anything else should be done on the child component directly (via the `styles` attribute in fabric for example)
            if (Object.entries(style).filter(function (_a) {
                var _b = __read(_a, 2), key = _b[0], value = _b[1];
                return value && key !== 'display';
            }).length > 0) {
                return [true, 'contentStyle'];
            }
        }
        return [false, undefined];
    };
    __decorate([
        Input(),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], ReactWrapperComponent.prototype, "contentClass", null);
    __decorate([
        Input(),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], ReactWrapperComponent.prototype, "contentStyle", null);
    return ReactWrapperComponent;
}());

export { AngularReactBrowserModule, Disguise, ReactContent, ReactTemplate, ReactWrapperComponent, createReactContentElement, createReactTemplateElement, getPassProps, passProp, registerElement, passPropsSymbol as ɵa, AngularReactRendererFactory as ɵb };
//# sourceMappingURL=angular-react-core.js.map
